(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object')
    module.exports = factory();
  else if (typeof define === 'function' && define.amd) define([], factory);
        else if (typeof exports === 'object') exports['deck'] = factory();
  else root['deck'] = factory();})(globalThis, function () {
"use strict";var __exports__=(()=>{var ni=Object.create;var tt=Object.defineProperty;var oi=Object.getOwnPropertyDescriptor;var si=Object.getOwnPropertyNames;var ii=Object.getPrototypeOf,ai=Object.prototype.hasOwnProperty;var wt=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),P=(t,e)=>{for(var r in e)tt(t,r,{get:e[r],enumerable:!0})},et=(t,e,r,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of si(e))!ai.call(t,o)&&o!==r&&tt(t,o,{get:()=>e[o],enumerable:!(n=oi(e,o))||n.enumerable});return t},q=(t,e,r)=>(et(t,e,"default"),r&&et(r,e,"default")),S=(t,e,r)=>(r=t!=null?ni(ii(t)):{},et(e||!t||!t.__esModule?tt(r,"default",{value:t,enumerable:!0}):r,t)),ci=t=>et(tt({},"__esModule",{value:!0}),t);var pe=wt((Dl,Zr)=>{Zr.exports=globalThis.deck});var se=wt((wl,en)=>{en.exports=globalThis.luma});var ve=wt((Nl,tn)=>{tn.exports=globalThis.luma});var $e={};P($e,{ScenegraphLayer:()=>ri,SimpleMeshLayer:()=>vo});var K={},$r=S(pe(),1);q(K,S(pe(),1));if(!$r.Layer)throw new Error("@deck.gl/core is not found");q($e,K);var te=S(pe(),1),Lo=S(se(),1),xe=S(ve(),1);var Hl=1/Math.PI*180,Ul=1/180*Math.PI,fi={EPSILON:1e-12,debug:!1,precision:4,printTypes:!1,printDegrees:!1,printRowMajor:!0,_cartographicRadians:!1};globalThis.mathgl=globalThis.mathgl||{config:{...fi}};var y=globalThis.mathgl.config;function rn(t,{precision:e=y.precision}={}){return t=li(t),`${parseFloat(t.toPrecision(e))}`}function Z(t){return Array.isArray(t)||ArrayBuffer.isView(t)&&!(t instanceof DataView)}function Nt(t,e,r){let n=y.EPSILON;r&&(y.EPSILON=r);try{if(t===e)return!0;if(Z(t)&&Z(e)){if(t.length!==e.length)return!1;for(let o=0;o<t.length;++o)if(!Nt(t[o],e[o]))return!1;return!0}return t&&t.equals?t.equals(e):e&&e.equals?e.equals(t):typeof t=="number"&&typeof e=="number"?Math.abs(t-e)<=y.EPSILON*Math.max(1,Math.abs(t),Math.abs(e)):!1}finally{y.EPSILON=n}}function li(t){return Math.round(t/y.EPSILON)*y.EPSILON}var $=class extends Array{clone(){return new this.constructor().copy(this)}fromArray(e,r=0){for(let n=0;n<this.ELEMENTS;++n)this[n]=e[n+r];return this.check()}toArray(e=[],r=0){for(let n=0;n<this.ELEMENTS;++n)e[r+n]=this[n];return e}toObject(e){return e}from(e){return Array.isArray(e)?this.copy(e):this.fromObject(e)}to(e){return e===this?this:Z(e)?this.toArray(e):this.toObject(e)}toTarget(e){return e?this.to(e):this}toFloat32Array(){return new Float32Array(this)}toString(){return this.formatString(y)}formatString(e){let r="";for(let n=0;n<this.ELEMENTS;++n)r+=(n>0?", ":"")+rn(this[n],e);return`${e.printTypes?this.constructor.name:""}[${r}]`}equals(e){if(!e||this.length!==e.length)return!1;for(let r=0;r<this.ELEMENTS;++r)if(!Nt(this[r],e[r]))return!1;return!0}exactEquals(e){if(!e||this.length!==e.length)return!1;for(let r=0;r<this.ELEMENTS;++r)if(this[r]!==e[r])return!1;return!0}negate(){for(let e=0;e<this.ELEMENTS;++e)this[e]=-this[e];return this.check()}lerp(e,r,n){if(n===void 0)return this.lerp(this,e,r);for(let o=0;o<this.ELEMENTS;++o){let s=e[o],i=typeof r=="number"?r:r[o];this[o]=s+n*(i-s)}return this.check()}min(e){for(let r=0;r<this.ELEMENTS;++r)this[r]=Math.min(e[r],this[r]);return this.check()}max(e){for(let r=0;r<this.ELEMENTS;++r)this[r]=Math.max(e[r],this[r]);return this.check()}clamp(e,r){for(let n=0;n<this.ELEMENTS;++n)this[n]=Math.min(Math.max(this[n],e[n]),r[n]);return this.check()}add(...e){for(let r of e)for(let n=0;n<this.ELEMENTS;++n)this[n]+=r[n];return this.check()}subtract(...e){for(let r of e)for(let n=0;n<this.ELEMENTS;++n)this[n]-=r[n];return this.check()}scale(e){if(typeof e=="number")for(let r=0;r<this.ELEMENTS;++r)this[r]*=e;else for(let r=0;r<this.ELEMENTS&&r<e.length;++r)this[r]*=e[r];return this.check()}multiplyByScalar(e){for(let r=0;r<this.ELEMENTS;++r)this[r]*=e;return this.check()}check(){if(y.debug&&!this.validate())throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);return this}validate(){let e=this.length===this.ELEMENTS;for(let r=0;r<this.ELEMENTS;++r)e=e&&Number.isFinite(this[r]);return e}sub(e){return this.subtract(e)}setScalar(e){for(let r=0;r<this.ELEMENTS;++r)this[r]=e;return this.check()}addScalar(e){for(let r=0;r<this.ELEMENTS;++r)this[r]+=e;return this.check()}subScalar(e){return this.addScalar(-e)}multiplyScalar(e){for(let r=0;r<this.ELEMENTS;++r)this[r]*=e;return this.check()}divideScalar(e){return this.multiplyByScalar(1/e)}clampScalar(e,r){for(let n=0;n<this.ELEMENTS;++n)this[n]=Math.min(Math.max(this[n],e),r);return this.check()}get elements(){return this}};function Ai(t,e){if(t.length!==e)return!1;for(let r=0;r<t.length;++r)if(!Number.isFinite(t[r]))return!1;return!0}function b(t){if(!Number.isFinite(t))throw new Error(`Invalid number ${JSON.stringify(t)}`);return t}function ee(t,e,r=""){if(y.debug&&!Ai(t,e))throw new Error(`math.gl: ${r} some fields set to invalid numbers'`);return t}function Ht(t,e){if(!t)throw new Error(`math.gl assertion ${e}`)}var he=class extends ${get x(){return this[0]}set x(e){this[0]=b(e)}get y(){return this[1]}set y(e){this[1]=b(e)}len(){return Math.sqrt(this.lengthSquared())}magnitude(){return this.len()}lengthSquared(){let e=0;for(let r=0;r<this.ELEMENTS;++r)e+=this[r]*this[r];return e}magnitudeSquared(){return this.lengthSquared()}distance(e){return Math.sqrt(this.distanceSquared(e))}distanceSquared(e){let r=0;for(let n=0;n<this.ELEMENTS;++n){let o=this[n]-e[n];r+=o*o}return b(r)}dot(e){let r=0;for(let n=0;n<this.ELEMENTS;++n)r+=this[n]*e[n];return b(r)}normalize(){let e=this.magnitude();if(e!==0)for(let r=0;r<this.ELEMENTS;++r)this[r]/=e;return this.check()}multiply(...e){for(let r of e)for(let n=0;n<this.ELEMENTS;++n)this[n]*=r[n];return this.check()}divide(...e){for(let r of e)for(let n=0;n<this.ELEMENTS;++n)this[n]/=r[n];return this.check()}lengthSq(){return this.lengthSquared()}distanceTo(e){return this.distance(e)}distanceToSquared(e){return this.distanceSquared(e)}getComponent(e){return Ht(e>=0&&e<this.ELEMENTS,"index is out of range"),b(this[e])}setComponent(e,r){return Ht(e>=0&&e<this.ELEMENTS,"index is out of range"),this[e]=r,this.check()}addVectors(e,r){return this.copy(e).add(r)}subVectors(e,r){return this.copy(e).subtract(r)}multiplyVectors(e,r){return this.copy(e).multiply(r)}addScaledVector(e,r){return this.add(new this.constructor(e).multiplyScalar(r))}};var I=typeof Float32Array<"u"?Float32Array:Array;var ql=Math.PI/180;function mi(){let t=new I(2);return I!=Float32Array&&(t[0]=0,t[1]=0),t}function sn(t,e,r){let n=e[0],o=e[1];return t[0]=r[0]*n+r[3]*o+r[6],t[1]=r[1]*n+r[4]*o+r[7],t}function an(t,e,r){let n=e[0],o=e[1];return t[0]=r[0]*n+r[4]*o+r[12],t[1]=r[1]*n+r[5]*o+r[13],t}var Zl=function(){let t=mi();return function(e,r,n,o,s,i){let a,c;for(r||(r=2),n||(n=0),o?c=Math.min(o*r+n,e.length):c=e.length,a=n;a<c;a+=r)t[0]=e[a],t[1]=e[a+1],s(t,t,i),e[a]=t[0],e[a+1]=t[1];return e}}();function cn(t,e,r){let n=e[0],o=e[1],s=r[3]*n+r[7]*o||1;return t[0]=(r[0]*n+r[4]*o)/s,t[1]=(r[1]*n+r[5]*o)/s,t}function rt(t,e,r){let n=e[0],o=e[1],s=e[2],i=r[3]*n+r[7]*o+r[11]*s||1;return t[0]=(r[0]*n+r[4]*o+r[8]*s)/i,t[1]=(r[1]*n+r[5]*o+r[9]*s)/i,t[2]=(r[2]*n+r[6]*o+r[10]*s)/i,t}function fn(t,e,r){let n=e[0],o=e[1];return t[0]=r[0]*n+r[2]*o,t[1]=r[1]*n+r[3]*o,t[2]=e[2],t}function ln(t,e,r){let n=e[0],o=e[1];return t[0]=r[0]*n+r[2]*o,t[1]=r[1]*n+r[3]*o,t[2]=e[2],t[3]=e[3],t}function nt(t,e,r){let n=e[0],o=e[1],s=e[2];return t[0]=r[0]*n+r[3]*o+r[6]*s,t[1]=r[1]*n+r[4]*o+r[7]*s,t[2]=r[2]*n+r[5]*o+r[8]*s,t[3]=e[3],t}function Ut(){let t=new I(3);return I!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t}function pi(t){let e=t[0],r=t[1],n=t[2];return Math.sqrt(e*e+r*r+n*n)}function Jt(t,e,r){let n=new I(3);return n[0]=t,n[1]=e,n[2]=r,n}function An(t,e){let r=e[0],n=e[1],o=e[2],s=r*r+n*n+o*o;return s>0&&(s=1/Math.sqrt(s)),t[0]=e[0]*s,t[1]=e[1]*s,t[2]=e[2]*s,t}function Kt(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]}function ue(t,e,r){let n=e[0],o=e[1],s=e[2],i=r[0],a=r[1],c=r[2];return t[0]=o*c-s*a,t[1]=s*i-n*c,t[2]=n*a-o*i,t}function de(t,e,r){let n=e[0],o=e[1],s=e[2],i=r[3]*n+r[7]*o+r[11]*s+r[15];return i=i||1,t[0]=(r[0]*n+r[4]*o+r[8]*s+r[12])/i,t[1]=(r[1]*n+r[5]*o+r[9]*s+r[13])/i,t[2]=(r[2]*n+r[6]*o+r[10]*s+r[14])/i,t}function ot(t,e,r){let n=e[0],o=e[1],s=e[2];return t[0]=n*r[0]+o*r[3]+s*r[6],t[1]=n*r[1]+o*r[4]+s*r[7],t[2]=n*r[2]+o*r[5]+s*r[8],t}function st(t,e,r){let n=r[0],o=r[1],s=r[2],i=r[3],a=e[0],c=e[1],f=e[2],l=o*f-s*c,A=s*a-n*f,m=n*c-o*a,p=o*m-s*A,h=s*l-n*m,u=n*A-o*l,g=i*2;return l*=g,A*=g,m*=g,p*=2,h*=2,u*=2,t[0]=a+l+p,t[1]=c+A+h,t[2]=f+m+u,t}function mn(t,e,r,n){let o=[],s=[];return o[0]=e[0]-r[0],o[1]=e[1]-r[1],o[2]=e[2]-r[2],s[0]=o[0],s[1]=o[1]*Math.cos(n)-o[2]*Math.sin(n),s[2]=o[1]*Math.sin(n)+o[2]*Math.cos(n),t[0]=s[0]+r[0],t[1]=s[1]+r[1],t[2]=s[2]+r[2],t}function pn(t,e,r,n){let o=[],s=[];return o[0]=e[0]-r[0],o[1]=e[1]-r[1],o[2]=e[2]-r[2],s[0]=o[2]*Math.sin(n)+o[0]*Math.cos(n),s[1]=o[1],s[2]=o[2]*Math.cos(n)-o[0]*Math.sin(n),t[0]=s[0]+r[0],t[1]=s[1]+r[1],t[2]=s[2]+r[2],t}function hn(t,e,r,n){let o=[],s=[];return o[0]=e[0]-r[0],o[1]=e[1]-r[1],o[2]=e[2]-r[2],s[0]=o[0]*Math.cos(n)-o[1]*Math.sin(n),s[1]=o[0]*Math.sin(n)+o[1]*Math.cos(n),s[2]=o[2],t[0]=s[0]+r[0],t[1]=s[1]+r[1],t[2]=s[2]+r[2],t}function un(t,e){let r=t[0],n=t[1],o=t[2],s=e[0],i=e[1],a=e[2],c=Math.sqrt((r*r+n*n+o*o)*(s*s+i*i+a*a)),f=c&&Kt(t,e)/c;return Math.acos(Math.min(Math.max(f,-1),1))}var dn=pi;var tA=function(){let t=Ut();return function(e,r,n,o,s,i){let a,c;for(r||(r=3),n||(n=0),o?c=Math.min(o*r+n,e.length):c=e.length,a=n;a<c;a+=r)t[0]=e[a],t[1]=e[a+1],t[2]=e[a+2],s(t,t,i),e[a]=t[0],e[a+1]=t[1],e[a+2]=t[2];return e}}();var Vt=[0,0,0],it,ie=class extends he{static get ZERO(){return it||(it=new ie(0,0,0),Object.freeze(it)),it}constructor(e=0,r=0,n=0){super(-0,-0,-0),arguments.length===1&&Z(e)?this.copy(e):(y.debug&&(b(e),b(r),b(n)),this[0]=e,this[1]=r,this[2]=n)}set(e,r,n){return this[0]=e,this[1]=r,this[2]=n,this.check()}copy(e){return this[0]=e[0],this[1]=e[1],this[2]=e[2],this.check()}fromObject(e){return y.debug&&(b(e.x),b(e.y),b(e.z)),this[0]=e.x,this[1]=e.y,this[2]=e.z,this.check()}toObject(e){return e.x=this[0],e.y=this[1],e.z=this[2],e}get ELEMENTS(){return 3}get z(){return this[2]}set z(e){this[2]=b(e)}angle(e){return un(this,e)}cross(e){return ue(this,this,e),this.check()}rotateX({radians:e,origin:r=Vt}){return mn(this,this,r,e),this.check()}rotateY({radians:e,origin:r=Vt}){return pn(this,this,r,e),this.check()}rotateZ({radians:e,origin:r=Vt}){return hn(this,this,r,e),this.check()}transform(e){return this.transformAsPoint(e)}transformAsPoint(e){return de(this,this,e),this.check()}transformAsVector(e){return rt(this,this,e),this.check()}transformByMatrix3(e){return ot(this,this,e),this.check()}transformByMatrix2(e){return fn(this,this,e),this.check()}transformByQuaternion(e){return st(this,this,e),this.check()}};var at,ge=class extends he{static get ZERO(){return at||(at=new ge(0,0,0,0),Object.freeze(at)),at}constructor(e=0,r=0,n=0,o=0){super(-0,-0,-0,-0),Z(e)&&arguments.length===1?this.copy(e):(y.debug&&(b(e),b(r),b(n),b(o)),this[0]=e,this[1]=r,this[2]=n,this[3]=o)}set(e,r,n,o){return this[0]=e,this[1]=r,this[2]=n,this[3]=o,this.check()}copy(e){return this[0]=e[0],this[1]=e[1],this[2]=e[2],this[3]=e[3],this.check()}fromObject(e){return y.debug&&(b(e.x),b(e.y),b(e.z),b(e.w)),this[0]=e.x,this[1]=e.y,this[2]=e.z,this[3]=e.w,this}toObject(e){return e.x=this[0],e.y=this[1],e.z=this[2],e.w=this[3],e}get ELEMENTS(){return 4}get z(){return this[2]}set z(e){this[2]=b(e)}get w(){return this[3]}set w(e){this[3]=b(e)}transform(e){return de(this,this,e),this.check()}transformByMatrix3(e){return nt(this,this,e),this.check()}transformByMatrix2(e){return ln(this,this,e),this.check()}transformByQuaternion(e){return st(this,this,e),this.check()}applyMatrix4(e){return e.transform(this,this),this}};var Be=class extends ${toString(){let e="[";if(y.printRowMajor){e+="row-major:";for(let r=0;r<this.RANK;++r)for(let n=0;n<this.RANK;++n)e+=` ${this[n*this.RANK+r]}`}else{e+="column-major:";for(let r=0;r<this.ELEMENTS;++r)e+=` ${this[r]}`}return e+="]",e}getElementIndex(e,r){return r*this.RANK+e}getElement(e,r){return this[r*this.RANK+e]}setElement(e,r,n){return this[r*this.RANK+e]=b(n),this}getColumn(e,r=new Array(this.RANK).fill(-0)){let n=e*this.RANK;for(let o=0;o<this.RANK;++o)r[o]=this[n+o];return r}setColumn(e,r){let n=e*this.RANK;for(let o=0;o<this.RANK;++o)this[n+o]=r[o];return this}};function gn(){let t=new I(9);return I!=Float32Array&&(t[1]=0,t[2]=0,t[3]=0,t[5]=0,t[6]=0,t[7]=0),t[0]=1,t[4]=1,t[8]=1,t}function Bn(t,e){if(t===e){let r=e[1],n=e[2],o=e[5];t[1]=e[3],t[2]=e[6],t[3]=r,t[5]=e[7],t[6]=n,t[7]=o}else t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8];return t}function Cn(t,e){let r=e[0],n=e[1],o=e[2],s=e[3],i=e[4],a=e[5],c=e[6],f=e[7],l=e[8],A=l*i-a*f,m=-l*s+a*c,p=f*s-i*c,h=r*A+n*m+o*p;return h?(h=1/h,t[0]=A*h,t[1]=(-l*n+o*f)*h,t[2]=(a*n-o*i)*h,t[3]=m*h,t[4]=(l*r-o*c)*h,t[5]=(-a*r+o*s)*h,t[6]=p*h,t[7]=(-f*r+n*c)*h,t[8]=(i*r-n*s)*h,t):null}function xn(t){let e=t[0],r=t[1],n=t[2],o=t[3],s=t[4],i=t[5],a=t[6],c=t[7],f=t[8];return e*(f*s-i*c)+r*(-f*o+i*a)+n*(c*o-s*a)}function Xt(t,e,r){let n=e[0],o=e[1],s=e[2],i=e[3],a=e[4],c=e[5],f=e[6],l=e[7],A=e[8],m=r[0],p=r[1],h=r[2],u=r[3],g=r[4],B=r[5],E=r[6],d=r[7],C=r[8];return t[0]=m*n+p*i+h*f,t[1]=m*o+p*a+h*l,t[2]=m*s+p*c+h*A,t[3]=u*n+g*i+B*f,t[4]=u*o+g*a+B*l,t[5]=u*s+g*c+B*A,t[6]=E*n+d*i+C*f,t[7]=E*o+d*a+C*l,t[8]=E*s+d*c+C*A,t}function Mn(t,e,r){let n=e[0],o=e[1],s=e[2],i=e[3],a=e[4],c=e[5],f=e[6],l=e[7],A=e[8],m=r[0],p=r[1];return t[0]=n,t[1]=o,t[2]=s,t[3]=i,t[4]=a,t[5]=c,t[6]=m*n+p*i+f,t[7]=m*o+p*a+l,t[8]=m*s+p*c+A,t}function En(t,e,r){let n=e[0],o=e[1],s=e[2],i=e[3],a=e[4],c=e[5],f=e[6],l=e[7],A=e[8],m=Math.sin(r),p=Math.cos(r);return t[0]=p*n+m*i,t[1]=p*o+m*a,t[2]=p*s+m*c,t[3]=p*i-m*n,t[4]=p*a-m*o,t[5]=p*c-m*s,t[6]=f,t[7]=l,t[8]=A,t}function jt(t,e,r){let n=r[0],o=r[1];return t[0]=n*e[0],t[1]=n*e[1],t[2]=n*e[2],t[3]=o*e[3],t[4]=o*e[4],t[5]=o*e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function bn(t,e){let r=e[0],n=e[1],o=e[2],s=e[3],i=r+r,a=n+n,c=o+o,f=r*i,l=n*i,A=n*a,m=o*i,p=o*a,h=o*c,u=s*i,g=s*a,B=s*c;return t[0]=1-A-h,t[3]=l-B,t[6]=m+g,t[1]=l+B,t[4]=1-f-h,t[7]=p-u,t[2]=m-g,t[5]=p+u,t[8]=1-f-A,t}var kt;(function(t){t[t.COL0ROW0=0]="COL0ROW0",t[t.COL0ROW1=1]="COL0ROW1",t[t.COL0ROW2=2]="COL0ROW2",t[t.COL1ROW0=3]="COL1ROW0",t[t.COL1ROW1=4]="COL1ROW1",t[t.COL1ROW2=5]="COL1ROW2",t[t.COL2ROW0=6]="COL2ROW0",t[t.COL2ROW1=7]="COL2ROW1",t[t.COL2ROW2=8]="COL2ROW2"})(kt||(kt={}));var di=Object.freeze([1,0,0,0,1,0,0,0,1]),Y=class extends Be{static get IDENTITY(){return Bi()}static get ZERO(){return gi()}get ELEMENTS(){return 9}get RANK(){return 3}get INDICES(){return kt}constructor(e,...r){super(-0,-0,-0,-0,-0,-0,-0,-0,-0),arguments.length===1&&Array.isArray(e)?this.copy(e):r.length>0?this.copy([e,...r]):this.identity()}copy(e){return this[0]=e[0],this[1]=e[1],this[2]=e[2],this[3]=e[3],this[4]=e[4],this[5]=e[5],this[6]=e[6],this[7]=e[7],this[8]=e[8],this.check()}identity(){return this.copy(di)}fromObject(e){return this.check()}fromQuaternion(e){return bn(this,e),this.check()}set(e,r,n,o,s,i,a,c,f){return this[0]=e,this[1]=r,this[2]=n,this[3]=o,this[4]=s,this[5]=i,this[6]=a,this[7]=c,this[8]=f,this.check()}setRowMajor(e,r,n,o,s,i,a,c,f){return this[0]=e,this[1]=o,this[2]=a,this[3]=r,this[4]=s,this[5]=c,this[6]=n,this[7]=i,this[8]=f,this.check()}determinant(){return xn(this)}transpose(){return Bn(this,this),this.check()}invert(){return Cn(this,this),this.check()}multiplyLeft(e){return Xt(this,e,this),this.check()}multiplyRight(e){return Xt(this,this,e),this.check()}rotate(e){return En(this,this,e),this.check()}scale(e){return Array.isArray(e)?jt(this,this,e):jt(this,this,[e,e]),this.check()}translate(e){return Mn(this,this,e),this.check()}transform(e,r){let n;switch(e.length){case 2:n=sn(r||[-0,-0],e,this);break;case 3:n=ot(r||[-0,-0,-0],e,this);break;case 4:n=nt(r||[-0,-0,-0,-0],e,this);break;default:throw new Error("Illegal vector")}return ee(n,e.length),n}transformVector(e,r){return this.transform(e,r)}transformVector2(e,r){return this.transform(e,r)}transformVector3(e,r){return this.transform(e,r)}},ct,ft=null;function gi(){return ct||(ct=new Y([0,0,0,0,0,0,0,0,0]),Object.freeze(ct)),ct}function Bi(){return ft||(ft=new Y,Object.freeze(ft)),ft}function Ci(t){return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function _n(t,e){if(t===e){let r=e[1],n=e[2],o=e[3],s=e[6],i=e[7],a=e[11];t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=r,t[6]=e[9],t[7]=e[13],t[8]=n,t[9]=s,t[11]=e[14],t[12]=o,t[13]=i,t[14]=a}else t[0]=e[0],t[1]=e[4],t[2]=e[8],t[3]=e[12],t[4]=e[1],t[5]=e[5],t[6]=e[9],t[7]=e[13],t[8]=e[2],t[9]=e[6],t[10]=e[10],t[11]=e[14],t[12]=e[3],t[13]=e[7],t[14]=e[11],t[15]=e[15];return t}function Tn(t,e){let r=e[0],n=e[1],o=e[2],s=e[3],i=e[4],a=e[5],c=e[6],f=e[7],l=e[8],A=e[9],m=e[10],p=e[11],h=e[12],u=e[13],g=e[14],B=e[15],E=r*a-n*i,d=r*c-o*i,C=r*f-s*i,x=n*c-o*a,M=n*f-s*a,L=o*f-s*c,v=l*u-A*h,G=l*g-m*h,O=l*B-p*h,H=A*g-m*u,U=A*B-p*u,J=m*B-p*g,T=E*J-d*U+C*H+x*O-M*G+L*v;return T?(T=1/T,t[0]=(a*J-c*U+f*H)*T,t[1]=(o*U-n*J-s*H)*T,t[2]=(u*L-g*M+B*x)*T,t[3]=(m*M-A*L-p*x)*T,t[4]=(c*O-i*J-f*G)*T,t[5]=(r*J-o*O+s*G)*T,t[6]=(g*C-h*L-B*d)*T,t[7]=(l*L-m*C+p*d)*T,t[8]=(i*U-a*O+f*v)*T,t[9]=(n*O-r*U-s*v)*T,t[10]=(h*M-u*C+B*E)*T,t[11]=(A*C-l*M-p*E)*T,t[12]=(a*G-i*H-c*v)*T,t[13]=(r*H-n*G+o*v)*T,t[14]=(u*d-h*x-g*E)*T,t[15]=(l*x-A*d+m*E)*T,t):null}function yn(t){let e=t[0],r=t[1],n=t[2],o=t[3],s=t[4],i=t[5],a=t[6],c=t[7],f=t[8],l=t[9],A=t[10],m=t[11],p=t[12],h=t[13],u=t[14],g=t[15],B=e*i-r*s,E=e*a-n*s,d=r*a-n*i,C=f*h-l*p,x=f*u-A*p,M=l*u-A*h,L=e*M-r*x+n*C,v=s*M-i*x+a*C,G=f*d-l*E+A*B,O=p*d-h*E+u*B;return c*L-o*v+g*G-m*O}function Qt(t,e,r){let n=e[0],o=e[1],s=e[2],i=e[3],a=e[4],c=e[5],f=e[6],l=e[7],A=e[8],m=e[9],p=e[10],h=e[11],u=e[12],g=e[13],B=e[14],E=e[15],d=r[0],C=r[1],x=r[2],M=r[3];return t[0]=d*n+C*a+x*A+M*u,t[1]=d*o+C*c+x*m+M*g,t[2]=d*s+C*f+x*p+M*B,t[3]=d*i+C*l+x*h+M*E,d=r[4],C=r[5],x=r[6],M=r[7],t[4]=d*n+C*a+x*A+M*u,t[5]=d*o+C*c+x*m+M*g,t[6]=d*s+C*f+x*p+M*B,t[7]=d*i+C*l+x*h+M*E,d=r[8],C=r[9],x=r[10],M=r[11],t[8]=d*n+C*a+x*A+M*u,t[9]=d*o+C*c+x*m+M*g,t[10]=d*s+C*f+x*p+M*B,t[11]=d*i+C*l+x*h+M*E,d=r[12],C=r[13],x=r[14],M=r[15],t[12]=d*n+C*a+x*A+M*u,t[13]=d*o+C*c+x*m+M*g,t[14]=d*s+C*f+x*p+M*B,t[15]=d*i+C*l+x*h+M*E,t}function Rn(t,e,r){let n=r[0],o=r[1],s=r[2],i,a,c,f,l,A,m,p,h,u,g,B;return e===t?(t[12]=e[0]*n+e[4]*o+e[8]*s+e[12],t[13]=e[1]*n+e[5]*o+e[9]*s+e[13],t[14]=e[2]*n+e[6]*o+e[10]*s+e[14],t[15]=e[3]*n+e[7]*o+e[11]*s+e[15]):(i=e[0],a=e[1],c=e[2],f=e[3],l=e[4],A=e[5],m=e[6],p=e[7],h=e[8],u=e[9],g=e[10],B=e[11],t[0]=i,t[1]=a,t[2]=c,t[3]=f,t[4]=l,t[5]=A,t[6]=m,t[7]=p,t[8]=h,t[9]=u,t[10]=g,t[11]=B,t[12]=i*n+l*o+h*s+e[12],t[13]=a*n+A*o+u*s+e[13],t[14]=c*n+m*o+g*s+e[14],t[15]=f*n+p*o+B*s+e[15]),t}function In(t,e,r){let n=r[0],o=r[1],s=r[2];return t[0]=e[0]*n,t[1]=e[1]*n,t[2]=e[2]*n,t[3]=e[3]*n,t[4]=e[4]*o,t[5]=e[5]*o,t[6]=e[6]*o,t[7]=e[7]*o,t[8]=e[8]*s,t[9]=e[9]*s,t[10]=e[10]*s,t[11]=e[11]*s,t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function Sn(t,e,r,n){let o=n[0],s=n[1],i=n[2],a=Math.sqrt(o*o+s*s+i*i),c,f,l,A,m,p,h,u,g,B,E,d,C,x,M,L,v,G,O,H,U,J,T,Le;return a<1e-6?null:(a=1/a,o*=a,s*=a,i*=a,f=Math.sin(r),c=Math.cos(r),l=1-c,A=e[0],m=e[1],p=e[2],h=e[3],u=e[4],g=e[5],B=e[6],E=e[7],d=e[8],C=e[9],x=e[10],M=e[11],L=o*o*l+c,v=s*o*l+i*f,G=i*o*l-s*f,O=o*s*l-i*f,H=s*s*l+c,U=i*s*l+o*f,J=o*i*l+s*f,T=s*i*l-o*f,Le=i*i*l+c,t[0]=A*L+u*v+d*G,t[1]=m*L+g*v+C*G,t[2]=p*L+B*v+x*G,t[3]=h*L+E*v+M*G,t[4]=A*O+u*H+d*U,t[5]=m*O+g*H+C*U,t[6]=p*O+B*H+x*U,t[7]=h*O+E*H+M*U,t[8]=A*J+u*T+d*Le,t[9]=m*J+g*T+C*Le,t[10]=p*J+B*T+x*Le,t[11]=h*J+E*T+M*Le,e!==t&&(t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t)}function Fn(t,e,r){let n=Math.sin(r),o=Math.cos(r),s=e[4],i=e[5],a=e[6],c=e[7],f=e[8],l=e[9],A=e[10],m=e[11];return e!==t&&(t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[4]=s*o+f*n,t[5]=i*o+l*n,t[6]=a*o+A*n,t[7]=c*o+m*n,t[8]=f*o-s*n,t[9]=l*o-i*n,t[10]=A*o-a*n,t[11]=m*o-c*n,t}function Ln(t,e,r){let n=Math.sin(r),o=Math.cos(r),s=e[0],i=e[1],a=e[2],c=e[3],f=e[8],l=e[9],A=e[10],m=e[11];return e!==t&&(t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=s*o-f*n,t[1]=i*o-l*n,t[2]=a*o-A*n,t[3]=c*o-m*n,t[8]=s*n+f*o,t[9]=i*n+l*o,t[10]=a*n+A*o,t[11]=c*n+m*o,t}function vn(t,e,r){let n=Math.sin(r),o=Math.cos(r),s=e[0],i=e[1],a=e[2],c=e[3],f=e[4],l=e[5],A=e[6],m=e[7];return e!==t&&(t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15]),t[0]=s*o+f*n,t[1]=i*o+l*n,t[2]=a*o+A*n,t[3]=c*o+m*n,t[4]=f*o-s*n,t[5]=l*o-i*n,t[6]=A*o-a*n,t[7]=m*o-c*n,t}function Gn(t,e){let r=e[0],n=e[1],o=e[2],s=e[3],i=r+r,a=n+n,c=o+o,f=r*i,l=n*i,A=n*a,m=o*i,p=o*a,h=o*c,u=s*i,g=s*a,B=s*c;return t[0]=1-A-h,t[1]=l+B,t[2]=m-g,t[3]=0,t[4]=l-B,t[5]=1-f-h,t[6]=p+u,t[7]=0,t[8]=m+g,t[9]=p-u,t[10]=1-f-A,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,t}function On(t,e,r,n,o,s,i){let a=1/(r-e),c=1/(o-n),f=1/(s-i);return t[0]=s*2*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=s*2*c,t[6]=0,t[7]=0,t[8]=(r+e)*a,t[9]=(o+n)*c,t[10]=(i+s)*f,t[11]=-1,t[12]=0,t[13]=0,t[14]=i*s*2*f,t[15]=0,t}function xi(t,e,r,n,o){let s=1/Math.tan(e/2);if(t[0]=s/r,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=s,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[11]=-1,t[12]=0,t[13]=0,t[15]=0,o!=null&&o!==1/0){let i=1/(n-o);t[10]=(o+n)*i,t[14]=2*o*n*i}else t[10]=-1,t[14]=-2*n;return t}var Dn=xi;function Mi(t,e,r,n,o,s,i){let a=1/(e-r),c=1/(n-o),f=1/(s-i);return t[0]=-2*a,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=-2*c,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=2*f,t[11]=0,t[12]=(e+r)*a,t[13]=(o+n)*c,t[14]=(i+s)*f,t[15]=1,t}var Pn=Mi;function wn(t,e,r,n){let o,s,i,a,c,f,l,A,m,p,h=e[0],u=e[1],g=e[2],B=n[0],E=n[1],d=n[2],C=r[0],x=r[1],M=r[2];return Math.abs(h-C)<1e-6&&Math.abs(u-x)<1e-6&&Math.abs(g-M)<1e-6?Ci(t):(A=h-C,m=u-x,p=g-M,o=1/Math.sqrt(A*A+m*m+p*p),A*=o,m*=o,p*=o,s=E*p-d*m,i=d*A-B*p,a=B*m-E*A,o=Math.sqrt(s*s+i*i+a*a),o?(o=1/o,s*=o,i*=o,a*=o):(s=0,i=0,a=0),c=m*a-p*i,f=p*s-A*a,l=A*i-m*s,o=Math.sqrt(c*c+f*f+l*l),o?(o=1/o,c*=o,f*=o,l*=o):(c=0,f=0,l=0),t[0]=s,t[1]=c,t[2]=A,t[3]=0,t[4]=i,t[5]=f,t[6]=m,t[7]=0,t[8]=a,t[9]=l,t[10]=p,t[11]=0,t[12]=-(s*h+i*u+a*g),t[13]=-(c*h+f*u+l*g),t[14]=-(A*h+m*u+p*g),t[15]=1,t)}function Ei(){let t=new I(4);return I!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0,t[3]=0),t}function Nn(t,e,r){return t[0]=e[0]+r[0],t[1]=e[1]+r[1],t[2]=e[2]+r[2],t[3]=e[3]+r[3],t}function Hn(t,e,r){return t[0]=e[0]*r,t[1]=e[1]*r,t[2]=e[2]*r,t[3]=e[3]*r,t}function Un(t){let e=t[0],r=t[1],n=t[2],o=t[3];return Math.sqrt(e*e+r*r+n*n+o*o)}function Jn(t){let e=t[0],r=t[1],n=t[2],o=t[3];return e*e+r*r+n*n+o*o}function Kn(t,e){let r=e[0],n=e[1],o=e[2],s=e[3],i=r*r+n*n+o*o+s*s;return i>0&&(i=1/Math.sqrt(i)),t[0]=r*i,t[1]=n*i,t[2]=o*i,t[3]=s*i,t}function Vn(t,e){return t[0]*e[0]+t[1]*e[1]+t[2]*e[2]+t[3]*e[3]}function Xn(t,e,r,n){let o=e[0],s=e[1],i=e[2],a=e[3];return t[0]=o+n*(r[0]-o),t[1]=s+n*(r[1]-s),t[2]=i+n*(r[2]-i),t[3]=a+n*(r[3]-a),t}function jn(t,e,r){let n=e[0],o=e[1],s=e[2],i=e[3];return t[0]=r[0]*n+r[4]*o+r[8]*s+r[12]*i,t[1]=r[1]*n+r[5]*o+r[9]*s+r[13]*i,t[2]=r[2]*n+r[6]*o+r[10]*s+r[14]*i,t[3]=r[3]*n+r[7]*o+r[11]*s+r[15]*i,t}function kn(t,e,r){let n=e[0],o=e[1],s=e[2],i=r[0],a=r[1],c=r[2],f=r[3],l=f*n+a*s-c*o,A=f*o+c*n-i*s,m=f*s+i*o-a*n,p=-i*n-a*o-c*s;return t[0]=l*f+p*-i+A*-c-m*-a,t[1]=A*f+p*-a+m*-i-l*-c,t[2]=m*f+p*-c+l*-a-A*-i,t[3]=e[3],t}var yA=function(){let t=Ei();return function(e,r,n,o,s,i){let a,c;for(r||(r=4),n||(n=0),o?c=Math.min(o*r+n,e.length):c=e.length,a=n;a<c;a+=r)t[0]=e[a],t[1]=e[a+1],t[2]=e[a+2],t[3]=e[a+3],s(t,t,i),e[a]=t[0],e[a+1]=t[1],e[a+2]=t[2],e[a+3]=t[3];return e}}();var Wt;(function(t){t[t.COL0ROW0=0]="COL0ROW0",t[t.COL0ROW1=1]="COL0ROW1",t[t.COL0ROW2=2]="COL0ROW2",t[t.COL0ROW3=3]="COL0ROW3",t[t.COL1ROW0=4]="COL1ROW0",t[t.COL1ROW1=5]="COL1ROW1",t[t.COL1ROW2=6]="COL1ROW2",t[t.COL1ROW3=7]="COL1ROW3",t[t.COL2ROW0=8]="COL2ROW0",t[t.COL2ROW1=9]="COL2ROW1",t[t.COL2ROW2=10]="COL2ROW2",t[t.COL2ROW3=11]="COL2ROW3",t[t.COL3ROW0=12]="COL3ROW0",t[t.COL3ROW1=13]="COL3ROW1",t[t.COL3ROW2=14]="COL3ROW2",t[t.COL3ROW3=15]="COL3ROW3"})(Wt||(Wt={}));var _i=45*Math.PI/180,Ti=1,zt=.1,Yt=500,yi=Object.freeze([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]),W=class extends Be{static get IDENTITY(){return Ii()}static get ZERO(){return Ri()}get ELEMENTS(){return 16}get RANK(){return 4}get INDICES(){return Wt}constructor(e){super(-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0),arguments.length===1&&Array.isArray(e)?this.copy(e):this.identity()}copy(e){return this[0]=e[0],this[1]=e[1],this[2]=e[2],this[3]=e[3],this[4]=e[4],this[5]=e[5],this[6]=e[6],this[7]=e[7],this[8]=e[8],this[9]=e[9],this[10]=e[10],this[11]=e[11],this[12]=e[12],this[13]=e[13],this[14]=e[14],this[15]=e[15],this.check()}set(e,r,n,o,s,i,a,c,f,l,A,m,p,h,u,g){return this[0]=e,this[1]=r,this[2]=n,this[3]=o,this[4]=s,this[5]=i,this[6]=a,this[7]=c,this[8]=f,this[9]=l,this[10]=A,this[11]=m,this[12]=p,this[13]=h,this[14]=u,this[15]=g,this.check()}setRowMajor(e,r,n,o,s,i,a,c,f,l,A,m,p,h,u,g){return this[0]=e,this[1]=s,this[2]=f,this[3]=p,this[4]=r,this[5]=i,this[6]=l,this[7]=h,this[8]=n,this[9]=a,this[10]=A,this[11]=u,this[12]=o,this[13]=c,this[14]=m,this[15]=g,this.check()}toRowMajor(e){return e[0]=this[0],e[1]=this[4],e[2]=this[8],e[3]=this[12],e[4]=this[1],e[5]=this[5],e[6]=this[9],e[7]=this[13],e[8]=this[2],e[9]=this[6],e[10]=this[10],e[11]=this[14],e[12]=this[3],e[13]=this[7],e[14]=this[11],e[15]=this[15],e}identity(){return this.copy(yi)}fromObject(e){return this.check()}fromQuaternion(e){return Gn(this,e),this.check()}frustum(e){let{left:r,right:n,bottom:o,top:s,near:i=zt,far:a=Yt}=e;return a===1/0?Si(this,r,n,o,s,i):On(this,r,n,o,s,i,a),this.check()}lookAt(e){let{eye:r,center:n=[0,0,0],up:o=[0,1,0]}=e;return wn(this,r,n,o),this.check()}ortho(e){let{left:r,right:n,bottom:o,top:s,near:i=zt,far:a=Yt}=e;return Pn(this,r,n,o,s,i,a),this.check()}orthographic(e){let{fovy:r=_i,aspect:n=Ti,focalDistance:o=1,near:s=zt,far:i=Yt}=e;Qn(r);let a=r/2,c=o*Math.tan(a),f=c*n;return this.ortho({left:-f,right:f,bottom:-c,top:c,near:s,far:i})}perspective(e){let{fovy:r=45*Math.PI/180,aspect:n=1,near:o=.1,far:s=500}=e;return Qn(r),Dn(this,r,n,o,s),this.check()}determinant(){return yn(this)}getScale(e=[-0,-0,-0]){return e[0]=Math.sqrt(this[0]*this[0]+this[1]*this[1]+this[2]*this[2]),e[1]=Math.sqrt(this[4]*this[4]+this[5]*this[5]+this[6]*this[6]),e[2]=Math.sqrt(this[8]*this[8]+this[9]*this[9]+this[10]*this[10]),e}getTranslation(e=[-0,-0,-0]){return e[0]=this[12],e[1]=this[13],e[2]=this[14],e}getRotation(e,r){e=e||[-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0,-0],r=r||[-0,-0,-0];let n=this.getScale(r),o=1/n[0],s=1/n[1],i=1/n[2];return e[0]=this[0]*o,e[1]=this[1]*s,e[2]=this[2]*i,e[3]=0,e[4]=this[4]*o,e[5]=this[5]*s,e[6]=this[6]*i,e[7]=0,e[8]=this[8]*o,e[9]=this[9]*s,e[10]=this[10]*i,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}getRotationMatrix3(e,r){e=e||[-0,-0,-0,-0,-0,-0,-0,-0,-0],r=r||[-0,-0,-0];let n=this.getScale(r),o=1/n[0],s=1/n[1],i=1/n[2];return e[0]=this[0]*o,e[1]=this[1]*s,e[2]=this[2]*i,e[3]=this[4]*o,e[4]=this[5]*s,e[5]=this[6]*i,e[6]=this[8]*o,e[7]=this[9]*s,e[8]=this[10]*i,e}transpose(){return _n(this,this),this.check()}invert(){return Tn(this,this),this.check()}multiplyLeft(e){return Qt(this,e,this),this.check()}multiplyRight(e){return Qt(this,this,e),this.check()}rotateX(e){return Fn(this,this,e),this.check()}rotateY(e){return Ln(this,this,e),this.check()}rotateZ(e){return vn(this,this,e),this.check()}rotateXYZ(e){return this.rotateX(e[0]).rotateY(e[1]).rotateZ(e[2])}rotateAxis(e,r){return Sn(this,this,e,r),this.check()}scale(e){return In(this,this,Array.isArray(e)?e:[e,e,e]),this.check()}translate(e){return Rn(this,this,e),this.check()}transform(e,r){return e.length===4?(r=jn(r||[-0,-0,-0,-0],e,this),ee(r,4),r):this.transformAsPoint(e,r)}transformAsPoint(e,r){let{length:n}=e,o;switch(n){case 2:o=an(r||[-0,-0],e,this);break;case 3:o=de(r||[-0,-0,-0],e,this);break;default:throw new Error("Illegal vector")}return ee(o,e.length),o}transformAsVector(e,r){let n;switch(e.length){case 2:n=cn(r||[-0,-0],e,this);break;case 3:n=rt(r||[-0,-0,-0],e,this);break;default:throw new Error("Illegal vector")}return ee(n,e.length),n}transformPoint(e,r){return this.transformAsPoint(e,r)}transformVector(e,r){return this.transformAsPoint(e,r)}transformDirection(e,r){return this.transformAsVector(e,r)}makeRotationX(e){return this.identity().rotateX(e)}makeTranslation(e,r,n){return this.identity().translate([e,r,n])}},lt,At;function Ri(){return lt||(lt=new W([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]),Object.freeze(lt)),lt}function Ii(){return At||(At=new W,Object.freeze(At)),At}function Qn(t){if(t>Math.PI*2)throw Error("expected radians")}function Si(t,e,r,n,o,s){let i=2*s/(r-e),a=2*s/(o-n),c=(r+e)/(r-e),f=(o+n)/(o-n),l=-1,A=-1,m=-2*s;return t[0]=i,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=a,t[6]=0,t[7]=0,t[8]=c,t[9]=f,t[10]=l,t[11]=A,t[12]=0,t[13]=0,t[14]=m,t[15]=0,t}function zn(){let t=new I(4);return I!=Float32Array&&(t[0]=0,t[1]=0,t[2]=0),t[3]=1,t}function Yn(t){return t[0]=0,t[1]=0,t[2]=0,t[3]=1,t}function qt(t,e,r){r=r*.5;let n=Math.sin(r);return t[0]=n*e[0],t[1]=n*e[1],t[2]=n*e[2],t[3]=Math.cos(r),t}function Zt(t,e,r){let n=e[0],o=e[1],s=e[2],i=e[3],a=r[0],c=r[1],f=r[2],l=r[3];return t[0]=n*l+i*a+o*f-s*c,t[1]=o*l+i*c+s*a-n*f,t[2]=s*l+i*f+n*c-o*a,t[3]=i*l-n*a-o*c-s*f,t}function Wn(t,e,r){r*=.5;let n=e[0],o=e[1],s=e[2],i=e[3],a=Math.sin(r),c=Math.cos(r);return t[0]=n*c+i*a,t[1]=o*c+s*a,t[2]=s*c-o*a,t[3]=i*c-n*a,t}function qn(t,e,r){r*=.5;let n=e[0],o=e[1],s=e[2],i=e[3],a=Math.sin(r),c=Math.cos(r);return t[0]=n*c-s*a,t[1]=o*c+i*a,t[2]=s*c+n*a,t[3]=i*c-o*a,t}function Zn(t,e,r){r*=.5;let n=e[0],o=e[1],s=e[2],i=e[3],a=Math.sin(r),c=Math.cos(r);return t[0]=n*c+o*a,t[1]=o*c-n*a,t[2]=s*c+i*a,t[3]=i*c-s*a,t}function $n(t,e){let r=e[0],n=e[1],o=e[2];return t[0]=r,t[1]=n,t[2]=o,t[3]=Math.sqrt(Math.abs(1-r*r-n*n-o*o)),t}function Oe(t,e,r,n){let o=e[0],s=e[1],i=e[2],a=e[3],c=r[0],f=r[1],l=r[2],A=r[3],m,p,h,u,g;return m=o*c+s*f+i*l+a*A,m<0&&(m=-m,c=-c,f=-f,l=-l,A=-A),1-m>1e-6?(p=Math.acos(m),g=Math.sin(p),h=Math.sin((1-n)*p)/g,u=Math.sin(n*p)/g):(h=1-n,u=n),t[0]=h*o+u*c,t[1]=h*s+u*f,t[2]=h*i+u*l,t[3]=h*a+u*A,t}function eo(t,e){let r=e[0],n=e[1],o=e[2],s=e[3],i=r*r+n*n+o*o+s*s,a=i?1/i:0;return t[0]=-r*a,t[1]=-n*a,t[2]=-o*a,t[3]=s*a,t}function to(t,e){return t[0]=-e[0],t[1]=-e[1],t[2]=-e[2],t[3]=e[3],t}function $t(t,e){let r=e[0]+e[4]+e[8],n;if(r>0)n=Math.sqrt(r+1),t[3]=.5*n,n=.5/n,t[0]=(e[5]-e[7])*n,t[1]=(e[6]-e[2])*n,t[2]=(e[1]-e[3])*n;else{let o=0;e[4]>e[0]&&(o=1),e[8]>e[o*3+o]&&(o=2);let s=(o+1)%3,i=(o+2)%3;n=Math.sqrt(e[o*3+o]-e[s*3+s]-e[i*3+i]+1),t[o]=.5*n,n=.5/n,t[3]=(e[s*3+i]-e[i*3+s])*n,t[s]=(e[s*3+o]+e[o*3+s])*n,t[i]=(e[i*3+o]+e[o*3+i])*n}return t}var ro=Nn;var no=Hn,oo=Vn,so=Xn,io=Un;var ao=Jn;var co=Kn;var fo=function(){let t=Ut(),e=Jt(1,0,0),r=Jt(0,1,0);return function(n,o,s){let i=Kt(o,s);return i<-.999999?(ue(t,e,o),dn(t)<1e-6&&ue(t,r,o),An(t,t),qt(n,t,Math.PI),n):i>.999999?(n[0]=0,n[1]=0,n[2]=0,n[3]=1,n):(ue(t,o,s),n[0]=t[0],n[1]=t[1],n[2]=t[2],n[3]=1+i,co(n,n))}}(),UA=function(){let t=zn(),e=zn();return function(r,n,o,s,i,a){return Oe(t,n,i,a),Oe(e,o,s,a),Oe(r,t,e,2*a*(1-a)),r}}(),JA=function(){let t=gn();return function(e,r,n,o){return t[0]=n[0],t[3]=n[1],t[6]=n[2],t[1]=o[0],t[4]=o[1],t[7]=o[2],t[2]=-r[0],t[5]=-r[1],t[8]=-r[2],co(e,$t(e,t))}}();var Fi=[0,0,0,1],De=class extends ${constructor(e=0,r=0,n=0,o=1){super(-0,-0,-0,-0),Array.isArray(e)&&arguments.length===1?this.copy(e):this.set(e,r,n,o)}copy(e){return this[0]=e[0],this[1]=e[1],this[2]=e[2],this[3]=e[3],this.check()}set(e,r,n,o){return this[0]=e,this[1]=r,this[2]=n,this[3]=o,this.check()}fromObject(e){return this[0]=e.x,this[1]=e.y,this[2]=e.z,this[3]=e.w,this.check()}fromMatrix3(e){return $t(this,e),this.check()}fromAxisRotation(e,r){return qt(this,e,r),this.check()}identity(){return Yn(this),this.check()}setAxisAngle(e,r){return this.fromAxisRotation(e,r)}get ELEMENTS(){return 4}get x(){return this[0]}set x(e){this[0]=b(e)}get y(){return this[1]}set y(e){this[1]=b(e)}get z(){return this[2]}set z(e){this[2]=b(e)}get w(){return this[3]}set w(e){this[3]=b(e)}len(){return io(this)}lengthSquared(){return ao(this)}dot(e){return oo(this,e)}rotationTo(e,r){return fo(this,e,r),this.check()}add(e){return ro(this,this,e),this.check()}calculateW(){return $n(this,this),this.check()}conjugate(){return to(this,this),this.check()}invert(){return eo(this,this),this.check()}lerp(e,r,n){return n===void 0?this.lerp(this,e,r):(so(this,e,r,n),this.check())}multiplyRight(e){return Zt(this,this,e),this.check()}multiplyLeft(e){return Zt(this,e,this),this.check()}normalize(){let e=this.len(),r=e>0?1/e:0;return this[0]=this[0]*r,this[1]=this[1]*r,this[2]=this[2]*r,this[3]=this[3]*r,e===0&&(this[3]=1),this.check()}rotateX(e){return Wn(this,this,e),this.check()}rotateY(e){return qn(this,this,e),this.check()}rotateZ(e){return Zn(this,this,e),this.check()}scale(e){return no(this,this,e),this.check()}slerp(e,r,n){let o,s,i;switch(arguments.length){case 1:({start:o=Fi,target:s,ratio:i}=e);break;case 2:o=this,s=e,i=r;break;default:o=e,s=r,i=n}return Oe(this,o,s,i),this.check()}transformVector4(e,r=new ge){return kn(r,e,this),ee(r,4)}lengthSq(){return this.lengthSquared()}setFromAxisAngle(e,r){return this.setAxisAngle(e,r)}premultiply(e){return this.multiplyLeft(e)}multiply(e){return this.multiplyRight(e)}};var Ao=S(se(),1);var er=`precision highp int;

// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  vec3 color;
};

struct PointLight {
  vec3 color;
  vec3 position;
  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform lightingUniforms {
  int enabled;
  int lightType;

  int directionalLightCount;
  int pointLightCount;

  vec3 ambientColor;

  vec3 lightColor0;
  vec3 lightPosition0;
  vec3 lightDirection0;
  vec3 lightAttenuation0;

  vec3 lightColor1;
  vec3 lightPosition1;
  vec3 lightDirection1;
  vec3 lightAttenuation1;

  vec3 lightColor2;
  vec3 lightPosition2;
  vec3 lightDirection2;
  vec3 lightAttenuation2;
} lighting;

PointLight lighting_getPointLight(int index) {
  switch (index) {
    case 0:
      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);
    case 1:
      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);
    case 2:
    default:  
      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);
  }
}

DirectionalLight lighting_getDirectionalLight(int index) {
  switch (index) {
    case 0:
      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);
    case 1:
      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);
    case 2:
    default:   
      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);
  }
} 

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

// #endif
`;var lo=`// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  color: vec3<f32>,
};

struct PointLight {
  color: vec3<f32>,
  position: vec3<f32>,
  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  color: vec3<f32>,
  direction: vec3<f32>,
};

struct lightingUniforms {
  enabled: i32,
  pointLightCount: i32,
  directionalLightCount: i32,

  ambientColor: vec3<f32>,

  // TODO - support multiple lights by uncommenting arrays below
  lightType: i32,
  lightColor: vec3<f32>,
  lightDirection: vec3<f32>,
  lightPosition: vec3<f32>,
  lightAttenuation: vec3<f32>,

  // AmbientLight ambientLight;
  // PointLight pointLight[MAX_LIGHTS];
  // DirectionalLight directionalLight[MAX_LIGHTS];
};

// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)
@binding(1) @group(0) var<uniform> lighting : lightingUniforms;

fn lighting_getPointLight(index: i32) -> PointLight {
  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);
}

fn lighting_getDirectionalLight(index: i32) -> DirectionalLight {
  return DirectionalLight(lighting.lightColor, lighting.lightDirection);
} 

fn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}
`;var Li=5,vi=255,Pe;(function(t){t[t.POINT=0]="POINT",t[t.DIRECTIONAL=1]="DIRECTIONAL"})(Pe||(Pe={}));var ae={props:{},uniforms:{},name:"lighting",defines:{},uniformTypes:{enabled:"i32",lightType:"i32",directionalLightCount:"i32",pointLightCount:"i32",ambientColor:"vec3<f32>",lightColor0:"vec3<f32>",lightPosition0:"vec3<f32>",lightDirection0:"vec3<f32>",lightAttenuation0:"vec3<f32>",lightColor1:"vec3<f32>",lightPosition1:"vec3<f32>",lightDirection1:"vec3<f32>",lightAttenuation1:"vec3<f32>",lightColor2:"vec3<f32>",lightPosition2:"vec3<f32>",lightDirection2:"vec3<f32>",lightAttenuation2:"vec3<f32>"},defaultUniforms:{enabled:1,lightType:Pe.POINT,directionalLightCount:0,pointLightCount:0,ambientColor:[.1,.1,.1],lightColor0:[1,1,1],lightPosition0:[1,1,2],lightDirection0:[1,1,1],lightAttenuation0:[1,0,0],lightColor1:[1,1,1],lightPosition1:[1,1,2],lightDirection1:[1,1,1],lightAttenuation1:[1,0,0],lightColor2:[1,1,1],lightPosition2:[1,1,2],lightDirection2:[1,1,1],lightAttenuation2:[1,0,0]},source:lo,vs:er,fs:er,getUniforms:Gi};function Gi(t,e={}){if(t=t&&{...t},!t)return{...ae.defaultUniforms};t.lights&&(t={...t,...Di(t.lights),lights:void 0});let{ambientLight:r,pointLights:n,directionalLights:o}=t||{};if(!(r||n&&n.length>0||o&&o.length>0))return{...ae.defaultUniforms,enabled:0};let i={...ae.defaultUniforms,...e,...Oi({ambientLight:r,pointLights:n,directionalLights:o})};return t.enabled!==void 0&&(i.enabled=t.enabled?1:0),i}function Oi({ambientLight:t,pointLights:e=[],directionalLights:r=[]}){let n={};n.ambientColor=tr(t);let o=0;for(let s of e){n.lightType=Pe.POINT;let i=o;n[`lightColor${i}`]=tr(s),n[`lightPosition${i}`]=s.position,n[`lightAttenuation${i}`]=s.attenuation||[1,0,0],o++}for(let s of r){n.lightType=Pe.DIRECTIONAL;let i=o;n[`lightColor${i}`]=tr(s),n[`lightDirection${i}`]=s.direction,o++}return o>Li&&Ao.log.warn("MAX_LIGHTS exceeded")(),n.directionalLightCount=r.length,n.pointLightCount=e.length,n}function Di(t){let e={pointLights:[],directionalLights:[]};for(let r of t||[])switch(r.type){case"ambient":e.ambientLight=r;break;case"directional":e.directionalLights?.push(r);break;case"point":e.pointLights?.push(r);break;default:}return e}function tr(t={}){let{color:e=[0,0,0],intensity:r=1}=t;return e.map(n=>n*r/vi)}var mo=`uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;
`,po=`#define MAX_LIGHTS 3

uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
  vec3 halfway_direction = normalize(light_direction + view_direction);
  float lambertian = dot(light_direction, normal_worldspace);
  float specular = 0.0;
  if (lambertian > 0.0) {
    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, material.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  vec3 view_direction = normalize(cameraPosition - position_worldspace);
  lightColor = material.ambient * surfaceColor * lighting.ambientColor;

  for (int i = 0; i < lighting.pointLightCount; i++) {
    PointLight pointLight = lighting_getPointLight(i);
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);
  }

  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);
  for (int i = lighting.pointLightCount; i < totalLights; i++) {
    DirectionalLight directionalLight = lighting_getDirectionalLight(i);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
}
`;var ho=`struct phongMaterialUniforms {
  ambient: f32,
  diffuse: f32,
  shininess: f32,
  specularColor: vec3<f32>,
};

@binding(2) @group(0) var<uniform> phongMaterial : phongMaterialUniforms;

fn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {
  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);
  var lambertian: f32 = dot(light_direction, normal_worldspace);
  var specular: f32 = 0.0;
  if (lambertian > 0.0) {
    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, phongMaterial.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * phongMaterial.diffuse * surfaceColor + specular * phongMaterial.specularColor) * color;
}

fn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {
  var lightColor: vec3<f32> = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);
  lightColor = phongMaterial.ambient * surfaceColor * lighting.ambientColor;

  if (lighting.lightType == 0) {
    let pointLight: PointLight  = lighting_getPointLight(0);
    let light_position_worldspace: vec3<f32> = pointLight.position;
    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  } else if (lighting.lightType == 1) {
    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
  /*
  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.pointLightCount) {
      break;
    }
    PointLight pointLight = lighting.pointLight[i];
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  }

  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.directionalLightCount) {
      break;
    }
    DirectionalLight directionalLight = lighting.directionalLight[i];
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  */
}

fn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{
  var lightColor = vec3<f32>(0, 0, 0);
  let surfaceColor = vec3<f32>(0, 0, 0);

  if (lighting.enabled == 0) {
    let view_direction = normalize(cameraPosition - position_worldspace);

    switch (lighting.lightType) {
      case 0, default: {
        let pointLight: PointLight = lighting_getPointLight(0);
        let light_position_worldspace: vec3<f32> = pointLight.position;
        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
      }
      case 1: {
        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
      }
    }
  }
  return lightColor;
}
`;var mt={name:"phongMaterial",dependencies:[ae],source:ho,vs:mo,fs:po,defines:{LIGHTING_FRAGMENT:!0},uniformTypes:{ambient:"f32",diffuse:"f32",shininess:"f32",specularColor:"vec3<f32>"},defaultUniforms:{ambient:.35,diffuse:.6,shininess:32,specularColor:[.15,.15,.15]},getUniforms(t){let e={...t};return e.specularColor&&(e.specularColor=e.specularColor.map(r=>r/255)),{...mt.defaultUniforms,...e}}};var uo=`out vec3 pbr_vPosition;
out vec2 pbr_vUV;

#ifdef HAS_NORMALS
# ifdef HAS_TANGENTS
out mat3 pbr_vTBN;
# else
out vec3 pbr_vNormal;
# endif
#endif

void pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)
{
  vec4 pos = pbrProjection.modelMatrix * position;
  pbr_vPosition = vec3(pos.xyz) / pos.w;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
  vec3 normalW = normalize(vec3(pbrProjection.normalMatrix * vec4(normal.xyz, 0.0)));
  vec3 tangentW = normalize(vec3(pbrProjection.modelMatrix * vec4(tangent.xyz, 0.0)));
  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
  pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else // HAS_TANGENTS != 1
  pbr_vNormal = normalize(vec3(pbrProjection.modelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif

#ifdef HAS_UV
  pbr_vUV = uv;
#else
  pbr_vUV = vec2(0.,0.);
#endif
}
`,go=`precision highp float;

uniform pbrMaterialUniforms {
  // Material is unlit
  bool unlit;

  // Base color map
  bool baseColorMapEnabled;
  vec4 baseColorFactor;

  bool normalMapEnabled;  
  float normalScale; // #ifdef HAS_NORMALMAP

  bool emissiveMapEnabled;
  vec3 emissiveFactor; // #ifdef HAS_EMISSIVEMAP

  vec2 metallicRoughnessValues;
  bool metallicRoughnessMapEnabled;

  bool occlusionMapEnabled;
  float occlusionStrength; // #ifdef HAS_OCCLUSIONMAP
  
  bool alphaCutoffEnabled;
  float alphaCutoff; // #ifdef ALPHA_CUTOFF
  
  // IBL
  bool IBLenabled;
  vec2 scaleIBLAmbient; // #ifdef USE_IBL
  
  // debugging flags used for shader output of intermediate PBR variables
  // #ifdef PBR_DEBUG
  vec4 scaleDiffBaseMR;
  vec4 scaleFGDSpec;
  // #endif
} pbrMaterial;

// Samplers
#ifdef HAS_BASECOLORMAP
uniform sampler2D pbr_baseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D pbr_normalSampler;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D pbr_emissiveSampler;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D pbr_metallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D pbr_occlusionSampler;
#endif
#ifdef USE_IBL
uniform samplerCube pbr_diffuseEnvSampler;
uniform samplerCube pbr_specularEnvSampler;
uniform sampler2D pbr_brdfLUT;
#endif

// Inputs from vertex shader

in vec3 pbr_vPosition;
in vec2 pbr_vUV;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
in mat3 pbr_vTBN;
#else
in vec3 pbr_vNormal;
#endif
#endif

// Encapsulate the various inputs used by the various functions in the shading equation
// We store values in this struct to simplify the integration of alternative implementations
// of the shading terms, outlined in the Readme.MD Appendix.
struct PBRInfo {
  float NdotL;                  // cos angle between normal and light direction
  float NdotV;                  // cos angle between normal and view direction
  float NdotH;                  // cos angle between normal and half vector
  float LdotH;                  // cos angle between light direction and half vector
  float VdotH;                  // cos angle between view direction and half vector
  float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
  float metalness;              // metallic value at the surface
  vec3 reflectance0;            // full reflectance color (normal incidence angle)
  vec3 reflectance90;           // reflectance color at grazing angle
  float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
  vec3 diffuseColor;            // color contribution from diffuse lighting
  vec3 specularColor;           // color contribution from specular lighting
  vec3 n;                       // normal at surface point
  vec3 v;                       // vector from surface point to camera
};

const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;

vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else // SRGB_FAST_APPROXIMATION
  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif //SRGB_FAST_APPROXIMATION
  return vec4(linOut,srgbIn.w);;
#else //MANUAL_SRGB
  return srgbIn;
#endif //MANUAL_SRGB
}

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
vec3 getNormal()
{
  // Retrieve the tangent space matrix
#ifndef HAS_TANGENTS
  vec3 pos_dx = dFdx(pbr_vPosition);
  vec3 pos_dy = dFdy(pbr_vPosition);
  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));
  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));
  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);

#ifdef HAS_NORMALS
  vec3 ng = normalize(pbr_vNormal);
#else
  vec3 ng = cross(pos_dx, pos_dy);
#endif

  t = normalize(t - ng * dot(ng, t));
  vec3 b = normalize(cross(ng, t));
  mat3 tbn = mat3(t, b, ng);
#else // HAS_TANGENTS
  mat3 tbn = pbr_vTBN;
#endif

#ifdef HAS_NORMALMAP
  vec3 n = texture(pbr_normalSampler, pbr_vUV).rgb;
  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(pbrMaterial.normalScale, pbrMaterial.normalScale, 1.0)));
#else
  // The tbn matrix is linearly interpolated, so we need to re-normalize
  vec3 n = normalize(tbn[2].xyz);
#endif

  return n;
}

// Calculation of the lighting contribution from an optional Image Based Light source.
// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].
// See our README.md on Environment Maps [3] for additional discussion.
#ifdef USE_IBL
vec3 getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection)
{
  float mipCount = 9.0; // resolution of 512x512
  float lod = (pbrInfo.perceptualRoughness * mipCount);
  // retrieve a scale and bias to F0. See [1], Figure 3
  vec3 brdf = SRGBtoLINEAR(texture(pbr_brdfLUT,
    vec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;
  vec3 diffuseLight = SRGBtoLINEAR(texture(pbr_diffuseEnvSampler, n)).rgb;

#ifdef USE_TEX_LOD
  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection, lod)).rgb;
#else
  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection)).rgb;
#endif

  vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;
  vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);

  // For presentation, this allows us to disable IBL terms
  diffuse *= pbrMaterial.scaleIBLAmbient.x;
  specular *= pbrMaterial.scaleIBLAmbient.y;

  return diffuse + specular;
}
#endif

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
vec3 diffuse(PBRInfo pbrInfo)
{
  return pbrInfo.diffuseColor / M_PI;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
vec3 specularReflection(PBRInfo pbrInfo)
{
  return pbrInfo.reflectance0 +
    (pbrInfo.reflectance90 - pbrInfo.reflectance0) *
    pow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
float geometricOcclusion(PBRInfo pbrInfo)
{
  float NdotL = pbrInfo.NdotL;
  float NdotV = pbrInfo.NdotV;
  float r = pbrInfo.alphaRoughness;

  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
  return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across
// the area being drawn (aka D())
// Implementation from "Average Irregularity Representation of a Roughened Surface
// for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes
// from EPIC Games [1], Equation 3.
float microfacetDistribution(PBRInfo pbrInfo)
{
  float roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;
  float f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;
  return roughnessSq / (M_PI * f * f);
}

void PBRInfo_setAmbientLight(inout PBRInfo pbrInfo) {
  pbrInfo.NdotL = 1.0;
  pbrInfo.NdotH = 0.0;
  pbrInfo.LdotH = 0.0;
  pbrInfo.VdotH = 1.0;
}

void PBRInfo_setDirectionalLight(inout PBRInfo pbrInfo, vec3 lightDirection) {
  vec3 n = pbrInfo.n;
  vec3 v = pbrInfo.v;
  vec3 l = normalize(lightDirection);             // Vector from surface point to light
  vec3 h = normalize(l+v);                        // Half vector between both l and v

  pbrInfo.NdotL = clamp(dot(n, l), 0.001, 1.0);
  pbrInfo.NdotH = clamp(dot(n, h), 0.0, 1.0);
  pbrInfo.LdotH = clamp(dot(l, h), 0.0, 1.0);
  pbrInfo.VdotH = clamp(dot(v, h), 0.0, 1.0);
}

void PBRInfo_setPointLight(inout PBRInfo pbrInfo, PointLight pointLight) {
  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);
  PBRInfo_setDirectionalLight(pbrInfo, light_direction);
}

vec3 calculateFinalColor(PBRInfo pbrInfo, vec3 lightColor) {
  // Calculate the shading terms for the microfacet specular shading model
  vec3 F = specularReflection(pbrInfo);
  float G = geometricOcclusion(pbrInfo);
  float D = microfacetDistribution(pbrInfo);

  // Calculation of analytical lighting contribution
  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInfo);
  vec3 specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);
  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
  return pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);
}

vec4 pbr_filterColor(vec4 colorUnused)
{
  // The albedo may be defined from a base texture or a flat color
#ifdef HAS_BASECOLORMAP
  vec4 baseColor = SRGBtoLINEAR(texture(pbr_baseColorSampler, pbr_vUV)) * pbrMaterial.baseColorFactor;
#else
  vec4 baseColor = pbrMaterial.baseColorFactor;
#endif

#ifdef ALPHA_CUTOFF
  if (baseColor.a < pbrMaterial.alphaCutoff) {
    discard;
  }
#endif

  vec3 color = vec3(0, 0, 0);

  if(pbrMaterial.unlit){
    color.rgb = baseColor.rgb;
  }
  else{
    // Metallic and Roughness material properties are packed together
    // In glTF, these factors can be specified by fixed scalar values
    // or from a metallic-roughness map
    float perceptualRoughness = pbrMaterial.metallicRoughnessValues.y;
    float metallic = pbrMaterial.metallicRoughnessValues.x;
#ifdef HAS_METALROUGHNESSMAP
    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.
    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data
    vec4 mrSample = texture(pbr_metallicRoughnessSampler, pbr_vUV);
    perceptualRoughness = mrSample.g * perceptualRoughness;
    metallic = mrSample.b * metallic;
#endif
    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
    metallic = clamp(metallic, 0.0, 1.0);
    // Roughness is authored as perceptual roughness; as is convention,
    // convert to material roughness by squaring the perceptual roughness [2].
    float alphaRoughness = perceptualRoughness * perceptualRoughness;

    vec3 f0 = vec3(0.04);
    vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
    diffuseColor *= 1.0 - metallic;
    vec3 specularColor = mix(f0, baseColor.rgb, metallic);

    // Compute reflectance.
    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    // For typical incident reflectance range (between 4% to 100%) set the grazing
    // reflectance to 100% for typical fresnel effect.
    // For very low reflectance range on highly diffuse objects (below 4%),
    // incrementally reduce grazing reflecance to 0%.
    float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    vec3 specularEnvironmentR0 = specularColor.rgb;
    vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

    vec3 n = getNormal();                          // normal at surface point
    vec3 v = normalize(pbrProjection.camera - pbr_vPosition);  // Vector from surface point to camera

    float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    vec3 reflection = -normalize(reflect(v, n));

    PBRInfo pbrInfo = PBRInfo(
      0.0, // NdotL
      NdotV,
      0.0, // NdotH
      0.0, // LdotH
      0.0, // VdotH
      perceptualRoughness,
      metallic,
      specularEnvironmentR0,
      specularEnvironmentR90,
      alphaRoughness,
      diffuseColor,
      specularColor,
      n,
      v
    );


#ifdef USE_LIGHTS
    // Apply ambient light
    PBRInfo_setAmbientLight(pbrInfo);
    color += calculateFinalColor(pbrInfo, lighting.ambientColor);

    // Apply directional light
    for(int i = 0; i < lighting.directionalLightCount; i++) {
      if (i < lighting.directionalLightCount) {
        PBRInfo_setDirectionalLight(pbrInfo, lighting_getDirectionalLight(i).direction);
        color += calculateFinalColor(pbrInfo, lighting_getDirectionalLight(i).color);
      }
    }

    // Apply point light
    for(int i = 0; i < lighting.pointLightCount; i++) {
      if (i < lighting.pointLightCount) {
        PBRInfo_setPointLight(pbrInfo, lighting_getPointLight(i));
        float attenuation = getPointLightAttenuation(lighting_getPointLight(i), distance(lighting_getPointLight(i).position, pbr_vPosition));
        color += calculateFinalColor(pbrInfo, lighting_getPointLight(i).color / attenuation);
      }
    }
#endif

    // Calculate lighting contribution from image based lighting source (IBL)
#ifdef USE_IBL
    if (pbrMaterial.IBLenabled) {
      color += getIBLContribution(pbrInfo, n, reflection);
    }
#endif

 // Apply optional PBR terms for additional (optional) shading
#ifdef HAS_OCCLUSIONMAP
    if (pbrMaterial.occlusionMapEnabled) {
      float ao = texture(pbr_occlusionSampler, pbr_vUV).r;
      color = mix(color, color * ao, pbrMaterial.occlusionStrength);
    }
#endif

#ifdef HAS_EMISSIVEMAP
    if (pbrMaterial.emissiveMapEnabled) {
      vec3 emissive = SRGBtoLINEAR(texture(pbr_emissiveSampler, pbr_vUV)).rgb * pbrMaterial.emissiveFactor;
      color += emissive;
    }
#endif

    // This section uses mix to override final color for reference app visualization
    // of various parameters in the lighting equation.
#ifdef PBR_DEBUG
    // TODO: Figure out how to debug multiple lights

    // color = mix(color, F, pbr_scaleFGDSpec.x);
    // color = mix(color, vec3(G), pbr_scaleFGDSpec.y);
    // color = mix(color, vec3(D), pbr_scaleFGDSpec.z);
    // color = mix(color, specContrib, pbr_scaleFGDSpec.w);

    // color = mix(color, diffuseContrib, pbr_scaleDiffBaseMR.x);
    color = mix(color, baseColor.rgb, pbrMaterial.scaleDiffBaseMR.y);
    color = mix(color, vec3(metallic), pbrMaterial.scaleDiffBaseMR.z);
    color = mix(color, vec3(perceptualRoughness), pbrMaterial.scaleDiffBaseMR.w);
#endif

  }

  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);
}
`;var Bo=`struct PBRFragmentInputs {
  pbr_vPosition: vec3f,
  pbr_vUV: vec2f,
  pbr_vTBN: mat3f,
  pbr_vNormal: vec3f
};

var fragmentInputs: PBRFragmentInputs;

fn pbr_setPositionNormalTangentUV(position: vec4f, normal: vec4f, tangent: vec4f, uv: vec2f)
{
  var pos: vec4f = pbrProjection.modelMatrix * position;
  pbr_vPosition = vec3(pos.xyz) / pos.w;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
  let normalW: vec3f = normalize(vec3(pbrProjection.normalMatrix * vec4(normal.xyz, 0.0)));
  let tangentW: vec3f = normalize(vec3(pbrProjection.modelMatrix * vec4(tangent.xyz, 0.0)));
  let bitangentW: vec3f = cross(normalW, tangentW) * tangent.w;
  fragmentInputs,pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else // HAS_TANGENTS != 1
  fragmentInputs.pbr_vNormal = normalize(vec3(pbrProjection.modelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif

#ifdef HAS_UV
  pbr_vUV = uv;
#else
  pbr_vUV = vec2(0.,0.);
#endif
}

struct pbrMaterialUniforms {
  // Material is unlit
  unlit: uint32,

  // Base color map
  baseColorMapEnabled: uint32,
  baseColorFactor: vec4f,

  normalMapEnabled : uint32,
  normalScale: f32,  // #ifdef HAS_NORMALMAP

  emissiveMapEnabled: uint32,
  emissiveFactor: vec3f, // #ifdef HAS_EMISSIVEMAP

  metallicRoughnessValues: vec2f,
  metallicRoughnessMapEnabled: uint32,

  occlusionMapEnabled: i32,
  occlusionStrength: f32, // #ifdef HAS_OCCLUSIONMAP
  
  alphaCutoffEnabled: i32,
  alphaCutoff: f32, // #ifdef ALPHA_CUTOFF
  
  // IBL
  IBLenabled: i32,
  scaleIBLAmbient: vec2f, // #ifdef USE_IBL
  
  // debugging flags used for shader output of intermediate PBR variables
  // #ifdef PBR_DEBUG
  scaleDiffBaseMR: vec4f,
  scaleFGDSpec: vec4f
  // #endif
} 
  
@binding(2) @group(0) var<uniform> material : pbrMaterialUniforms;

// Samplers
#ifdef HAS_BASECOLORMAP
uniform sampler2D pbr_baseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D pbr_normalSampler;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D pbr_emissiveSampler;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D pbr_metallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D pbr_occlusionSampler;
#endif
#ifdef USE_IBL
uniform samplerCube pbr_diffuseEnvSampler;
uniform samplerCube pbr_specularEnvSampler;
uniform sampler2D pbr_brdfLUT;
#endif

// Encapsulate the various inputs used by the various functions in the shading equation
// We store values in this struct to simplify the integration of alternative implementations
// of the shading terms, outlined in the Readme.MD Appendix.
struct PBRInfo {
  NdotL: f32,                  // cos angle between normal and light direction
  NdotV: f32,                  // cos angle between normal and view direction
  NdotH: f32,                  // cos angle between normal and half vector
  LdotH: f32,                  // cos angle between light direction and half vector
  VdotH: f32,                  // cos angle between view direction and half vector
  perceptualRoughness: f32,    // roughness value, as authored by the model creator (input to shader)
  metalness: f32,              // metallic value at the surface
  reflectance0: vec3f,            // full reflectance color (normal incidence angle)
  reflectance90: vec3f,           // reflectance color at grazing angle
  alphaRoughness: f32,         // roughness mapped to a more linear change in the roughness (proposed by [2])
  diffuseColor: vec3f,            // color contribution from diffuse lighting
  specularColor: vec3f,           // color contribution from specular lighting
  n: vec3f,                       // normal at surface point
  v: vec3f,                       // vector from surface point to camera
};

const M_PI = 3.141592653589793;
const c_MinRoughness = 0.04;

fn SRGBtoLINEAR(srgbIn: vec4f ) -> vec4f
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
  var linOut: vec3f = pow(srgbIn.xyz,vec3(2.2));
#else // SRGB_FAST_APPROXIMATION
  var bLess: vec3f = step(vec3(0.04045),srgbIn.xyz);
  var linOut: vec3f = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif //SRGB_FAST_APPROXIMATION
  return vec4f(linOut,srgbIn.w);;
#else //MANUAL_SRGB
  return srgbIn;
#endif //MANUAL_SRGB
}

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
fn getNormal() -> vec3f
{
  // Retrieve the tangent space matrix
#ifndef HAS_TANGENTS
  var pos_dx: vec3f = dFdx(pbr_vPosition);
  var pos_dy: vec3f = dFdy(pbr_vPosition);
  var tex_dx: vec3f = dFdx(vec3(pbr_vUV, 0.0));
  var tex_dy: vec3f = dFdy(vec3(pbr_vUV, 0.0));
  var t: vec3f = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);

#ifdef HAS_NORMALS
  var ng: vec3f = normalize(pbr_vNormal);
#else
  var ng: vec3f = cross(pos_dx, pos_dy);
#endif

  t = normalize(t - ng * dot(ng, t));
  var b: vec3f = normalize(cross(ng, t));
  var tbn: mat3f = mat3f(t, b, ng);
#else // HAS_TANGENTS
  var tbn: mat3f = pbr_vTBN;
#endif

#ifdef HAS_NORMALMAP
  vec3 n = texture(pbr_normalSampler, pbr_vUV).rgb;
  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(pbrMaterial.normalScale, pbrMaterial.normalScale, 1.0)));
#else
  // The tbn matrix is linearly interpolated, so we need to re-normalize
  vec3 n = normalize(tbn[2].xyz);
#endif

  return n;
}

// Calculation of the lighting contribution from an optional Image Based Light source.
// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].
// See our README.md on Environment Maps [3] for additional discussion.
#ifdef USE_IBL
fn getIBLContribution(PBRInfo pbrInfo, vec3 n, vec3 reflection) -> vec3f
{
  float mipCount = 9.0; // resolution of 512x512
  float lod = (pbrInfo.perceptualRoughness * mipCount);
  // retrieve a scale and bias to F0. See [1], Figure 3
  vec3 brdf = SRGBtoLINEAR(texture(pbr_brdfLUT,
    vec2(pbrInfo.NdotV, 1.0 - pbrInfo.perceptualRoughness))).rgb;
  vec3 diffuseLight = SRGBtoLINEAR(texture(pbr_diffuseEnvSampler, n)).rgb;

#ifdef USE_TEX_LOD
  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection, lod)).rgb;
#else
  vec3 specularLight = SRGBtoLINEAR(texture(pbr_specularEnvSampler, reflection)).rgb;
#endif

  vec3 diffuse = diffuseLight * pbrInfo.diffuseColor;
  vec3 specular = specularLight * (pbrInfo.specularColor * brdf.x + brdf.y);

  // For presentation, this allows us to disable IBL terms
  diffuse *= pbrMaterial.scaleIBLAmbient.x;
  specular *= pbrMaterial.scaleIBLAmbient.y;

  return diffuse + specular;
}
#endif

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
fn diffuse(pbrInfo: PBRInfo) -> vec3<f32> {
  return pbrInfo.diffuseColor / PI;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
fn specularReflection(pbrInfo: PBRInfo) -> vec3<f32> {
  return pbrInfo.reflectance0 +
    (pbrInfo.reflectance90 - pbrInfo.reflectance0) *
    pow(clamp(1.0 - pbrInfo.VdotH, 0.0, 1.0), 5.0);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
fn geometricOcclusion(pbrInfo: PBRInfo) -> f32 {
  let NdotL: f32 = pbrInfo.NdotL;
  let NdotV: f32 = pbrInfo.NdotV;
  let r: f32 = pbrInfo.alphaRoughness;

  let attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
  let attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
  return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across
// the area being drawn (aka D())
// Implementation from "Average Irregularity Representation of a Roughened Surface
// for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes
// from EPIC Games [1], Equation 3.
fn microfacetDistribution(pbrInfo: PBRInfo) -> f32 {
  let roughnessSq = pbrInfo.alphaRoughness * pbrInfo.alphaRoughness;
  let f = (pbrInfo.NdotH * roughnessSq - pbrInfo.NdotH) * pbrInfo.NdotH + 1.0;
  return roughnessSq / (PI * f * f);
}

fn PBRInfo_setAmbientLight(pbrInfo: ptr<function, PBRInfo>) {
  (*pbrInfo).NdotL = 1.0;
  (*pbrInfo).NdotH = 0.0;
  (*pbrInfo).LdotH = 0.0;
  (*pbrInfo).VdotH = 1.0;
}

fn PBRInfo_setDirectionalLight(pbrInfo: ptr<function, PBRInfo>, lightDirection: vec3<f32>) {
  let n = (*pbrInfo).n;
  let v = (*pbrInfo).v;
  let l = normalize(lightDirection);             // Vector from surface point to light
  let h = normalize(l + v);                      // Half vector between both l and v

  (*pbrInfo).NdotL = clamp(dot(n, l), 0.001, 1.0);
  (*pbrInfo).NdotH = clamp(dot(n, h), 0.0, 1.0);
  (*pbrInfo).LdotH = clamp(dot(l, h), 0.0, 1.0);
  (*pbrInfo).VdotH = clamp(dot(v, h), 0.0, 1.0);
}

fn PBRInfo_setPointLight(pbrInfo: ptr<function, PBRInfo>, pointLight: PointLight) {
  let light_direction = normalize(pointLight.position - pbr_vPosition);
  PBRInfo_setDirectionalLight(pbrInfo, light_direction);
}

fn calculateFinalColor(pbrInfo: PBRInfo, lightColor: vec3<f32>) -> vec3<f32> {
  // Calculate the shading terms for the microfacet specular shading model
  let F = specularReflection(pbrInfo);
  let G = geometricOcclusion(pbrInfo);
  let D = microfacetDistribution(pbrInfo);

  // Calculation of analytical lighting contribution
  let diffuseContrib = (1.0 - F) * diffuse(pbrInfo);
  let specContrib = F * G * D / (4.0 * pbrInfo.NdotL * pbrInfo.NdotV);
  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
  return pbrInfo.NdotL * lightColor * (diffuseContrib + specContrib);
}

fn pbr_filterColor(colorUnused: vec4<f32>) -> vec4<f32> {
  // The albedo may be defined from a base texture or a flat color
  var baseColor: vec4<f32>;
  #ifdef HAS_BASECOLORMAP
  baseColor = SRGBtoLINEAR(textureSample(pbr_baseColorSampler, pbr_baseColorSampler, pbr_vUV)) * pbrMaterial.baseColorFactor;
  #else
  baseColor = pbrMaterial.baseColorFactor;
  #endif

  #ifdef ALPHA_CUTOFF
  if (baseColor.a < pbrMaterial.alphaCutoff) {
    discard;
  }
  #endif

  var color = vec3<f32>(0.0, 0.0, 0.0);

  if (pbrMaterial.unlit) {
    color = baseColor.rgb;
  } else {
    // Metallic and Roughness material properties are packed together
    // In glTF, these factors can be specified by fixed scalar values
    // or from a metallic-roughness map
    var perceptualRoughness = pbrMaterial.metallicRoughnessValues.y;
    var metallic = pbrMaterial.metallicRoughnessValues.x;
    #ifdef HAS_METALROUGHNESSMAP
    // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.
    // This layout intentionally reserves the 'r' channel for (optional) occlusion map data
    let mrSample = textureSample(pbr_metallicRoughnessSampler, pbr_metallicRoughnessSampler, pbr_vUV);
    perceptualRoughness = mrSample.g * perceptualRoughness;
    metallic = mrSample.b * metallic;
    #endif
    perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
    metallic = clamp(metallic, 0.0, 1.0);
    // Roughness is authored as perceptual roughness; as is convention,
    // convert to material roughness by squaring the perceptual roughness [2].
    let alphaRoughness = perceptualRoughness * perceptualRoughness;

    let f0 = vec3<f32>(0.04);
    var diffuseColor = baseColor.rgb * (vec3<f32>(1.0) - f0);
    diffuseColor *= 1.0 - metallic;
    let specularColor = mix(f0, baseColor.rgb, metallic);

    // Compute reflectance.
    let reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

    // For typical incident reflectance range (between 4% to 100%) set the grazing
    // reflectance to 100% for typical fresnel effect.
    // For very low reflectance range on highly diffuse objects (below 4%),
    // incrementally reduce grazing reflectance to 0%.
    let reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
    let specularEnvironmentR0 = specularColor;
    let specularEnvironmentR90 = vec3<f32>(1.0, 1.0, 1.0) * reflectance90;

    let n = getNormal();                          // normal at surface point
    let v = normalize(pbrProjection.camera - pbr_vPosition);  // Vector from surface point to camera

    let NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
    let reflection = -normalize(reflect(v, n));

    var pbrInfo = PBRInfo(
      0.0, // NdotL
      NdotV,
      0.0, // NdotH
      0.0, // LdotH
      0.0, // VdotH
      perceptualRoughness,
      metallic,
      specularEnvironmentR0,
      specularEnvironmentR90,
      alphaRoughness,
      diffuseColor,
      specularColor,
      n,
      v
    );

    #ifdef USE_LIGHTS
    // Apply ambient light
    PBRInfo_setAmbientLight(&pbrInfo);
    color += calculateFinalColor(pbrInfo, lighting.ambientColor);

    // Apply directional light
    for (var i = 0; i < lighting.directionalLightCount; i++) {
      if (i < lighting.directionalLightCount) {
        PBRInfo_setDirectionalLight(&pbrInfo, lighting_getDirectionalLight(i).direction);
        color += calculateFinalColor(pbrInfo, lighting_getDirectionalLight(i).color);
      }
    }

    // Apply point light
    for (var i = 0; i < lighting.pointLightCount; i++) {
      if (i < lighting.pointLightCount) {
        PBRInfo_setPointLight(&pbrInfo, lighting_getPointLight(i));
        let attenuation = getPointLightAttenuation(lighting_getPointLight(i), distance(lighting_getPointLight(i).position, pbr_vPosition));
        color += calculateFinalColor(pbrInfo, lighting_getPointLight(i).color / attenuation);
      }
    }
    #endif

    // Calculate lighting contribution from image based lighting source (IBL)
    #ifdef USE_IBL
    if (pbrMaterial.IBLenabled) {
      color += getIBLContribution(pbrInfo, n, reflection);
    }
    #endif

    // Apply optional PBR terms for additional (optional) shading
    #ifdef HAS_OCCLUSIONMAP
    if (pbrMaterial.occlusionMapEnabled) {
      let ao = textureSample(pbr_occlusionSampler, pbr_occlusionSampler, pbr_vUV).r;
      color = mix(color, color * ao, pbrMaterial.occlusionStrength);
    }
    #endif

    #ifdef HAS_EMISSIVEMAP
    if (pbrMaterial.emissiveMapEnabled) {
      let emissive = SRGBtoLINEAR(textureSample(pbr_emissiveSampler, pbr_emissiveSampler, pbr_vUV)).rgb * pbrMaterial.emissiveFactor;
      color += emissive;
    }
    #endif

    // This section uses mix to override final color for reference app visualization
    // of various parameters in the lighting equation.
    #ifdef PBR_DEBUG
    // TODO: Figure out how to debug multiple lights

    // color = mix(color, F, pbr_scaleFGDSpec.x);
    // color = mix(color, vec3(G), pbr_scaleFGDSpec.y);
    // color = mix(color, vec3(D), pbr_scaleFGDSpec.z);
    // color = mix(color, specContrib, pbr_scaleFGDSpec.w);

    // color = mix(color, diffuseContrib, pbr_scaleDiffBaseMR.x);
    color = mix(color, baseColor.rgb, pbrMaterial.scaleDiffBaseMR.y);
    color = mix(color, vec3<f32>(metallic), pbrMaterial.scaleDiffBaseMR.z);
    color = mix(color, vec3<f32>(perceptualRoughness), pbrMaterial.scaleDiffBaseMR.w);
    #endif
  }

  return vec4<f32>(pow(color, vec3<f32>(1.0 / 2.2)), baseColor.a);
}
`;var Co=`uniform pbrProjectionUniforms {
  mat4 modelViewProjectionMatrix;
  mat4 modelMatrix;
  mat4 normalMatrix;
  vec3 camera;
} pbrProjection;
`,xo={name:"pbrProjection",vs:Co,fs:Co,getUniforms:t=>t,uniformTypes:{modelViewProjectionMatrix:"mat4x4<f32>",modelMatrix:"mat4x4<f32>",normalMatrix:"mat4x4<f32>",camera:"vec3<i32>"}};var we={props:{},uniforms:{},name:"pbrMaterial",dependencies:[ae,xo],source:Bo,vs:uo,fs:go,defines:{LIGHTING_FRAGMENT:!0,HAS_NORMALMAP:!1,HAS_EMISSIVEMAP:!1,HAS_OCCLUSIONMAP:!1,HAS_BASECOLORMAP:!1,HAS_METALROUGHNESSMAP:!1,ALPHA_CUTOFF:!1,USE_IBL:!1,PBR_DEBUG:!1},getUniforms:t=>t,uniformTypes:{unlit:"i32",baseColorMapEnabled:"i32",baseColorFactor:"vec4<f32>",normalMapEnabled:"i32",normalScale:"f32",emissiveMapEnabled:"i32",emissiveFactor:"vec3<f32>",metallicRoughnessValues:"vec2<f32>",metallicRoughnessMapEnabled:"i32",occlusionMapEnabled:"i32",occlusionStrength:"f32",alphaCutoffEnabled:"i32",alphaCutoff:"f32",IBLenabled:"i32",scaleIBLAmbient:"vec2<f32>",scaleDiffBaseMR:"vec4<f32>",scaleFGDSpec:"vec4<f32>"}};var Ce=S(pe(),1),rr=Math.PI/180,pt=new Float32Array(16),Mo=new Float32Array(12);function Eo(t,e,r){let n=e[0]*rr,o=e[1]*rr,s=e[2]*rr,i=Math.sin(s),a=Math.sin(n),c=Math.sin(o),f=Math.cos(s),l=Math.cos(n),A=Math.cos(o),m=r[0],p=r[1],h=r[2];t[0]=m*A*l,t[1]=m*c*l,t[2]=m*-a,t[3]=p*(-c*f+A*a*i),t[4]=p*(A*f+c*a*i),t[5]=p*l*i,t[6]=h*(c*i+A*a*f),t[7]=h*(-A*i+c*a*f),t[8]=h*l*f}function bo(t){return t[0]=t[0],t[1]=t[1],t[2]=t[2],t[3]=t[4],t[4]=t[5],t[5]=t[6],t[6]=t[8],t[7]=t[9],t[8]=t[10],t[9]=t[12],t[10]=t[13],t[11]=t[14],t.subarray(0,12)}var ht={size:12,accessor:["getOrientation","getScale","getTranslation","getTransformMatrix"],shaderAttributes:{instanceModelMatrixCol0:{size:3,elementOffset:0},instanceModelMatrixCol1:{size:3,elementOffset:3},instanceModelMatrixCol2:{size:3,elementOffset:6},instanceTranslation:{size:3,elementOffset:9}},update(t,{startRow:e,endRow:r}){let{data:n,getOrientation:o,getScale:s,getTranslation:i,getTransformMatrix:a}=this.props,c=Array.isArray(a),f=c&&a.length===16,l=Array.isArray(s),A=Array.isArray(o),m=Array.isArray(i),p=f||!c&&Boolean(a(n[0]));p?t.constant=f:t.constant=A&&l&&m;let h=t.value;if(t.constant){let u;p?(pt.set(a),u=bo(pt)):(u=Mo,Eo(u,o,s),u.set(i,9)),t.value=new Float32Array(u)}else{let u=e*t.size,{iterable:g,objectInfo:B}=(0,Ce.createIterable)(n,e,r);for(let E of g){B.index++;let d;if(p)pt.set(f?a:a(E,B)),d=bo(pt);else{d=Mo;let C=A?o:o(E,B),x=l?s:s(E,B);Eo(d,C,x),d.set(m?i:i(E,B),9)}h[u++]=d[0],h[u++]=d[1],h[u++]=d[2],h[u++]=d[3],h[u++]=d[4],h[u++]=d[5],h[u++]=d[6],h[u++]=d[7],h[u++]=d[8],h[u++]=d[9],h[u++]=d[10],h[u++]=d[11]}}}};function ut(t,e){return e===Ce.COORDINATE_SYSTEM.CARTESIAN||e===Ce.COORDINATE_SYSTEM.METER_OFFSETS||e===Ce.COORDINATE_SYSTEM.DEFAULT&&!t.isGeospatial}var _o=`uniform simpleMeshUniforms {
  float sizeScale;
  bool composeModelMatrix;
  bool hasTexture;
  bool flatShading;
} simpleMesh;
`,To={name:"simpleMesh",vs:_o,fs:_o,uniformTypes:{sizeScale:"f32",composeModelMatrix:"f32",hasTexture:"f32",flatShading:"f32"}};var yo=`#version 300 es
#define SHADER_NAME simple-mesh-layer-vs
in vec3 positions;
in vec3 normals;
in vec3 colors;
in vec2 texCoords;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
out vec2 vTexCoord;
out vec3 cameraPosition;
out vec3 normals_commonspace;
out vec4 position_commonspace;
out vec4 vColor;
void main(void) {
geometry.worldPosition = instancePositions;
geometry.uv = texCoords;
geometry.pickingColor = instancePickingColors;
vTexCoord = texCoords;
cameraPosition = project.cameraPosition;
vColor = vec4(colors * instanceColors.rgb, instanceColors.a);
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 pos = (instanceModelMatrix * positions) * simpleMesh.sizeScale + instanceTranslation;
if (simpleMesh.composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
normals_commonspace = project_normal(instanceModelMatrix * normals);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), position_commonspace);
geometry.position = position_commonspace;
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, position_commonspace);
geometry.position = position_commonspace;
normals_commonspace = project_normal(instanceModelMatrix * normals);
}
geometry.normal = normals_commonspace;
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;var Ro=`#version 300 es
#define SHADER_NAME simple-mesh-layer-fs
precision highp float;
uniform sampler2D sampler;
in vec2 vTexCoord;
in vec3 cameraPosition;
in vec3 normals_commonspace;
in vec4 position_commonspace;
in vec4 vColor;
out vec4 fragColor;
void main(void) {
geometry.uv = vTexCoord;
vec3 normal;
if (simpleMesh.flatShading) {
normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
} else {
normal = normals_commonspace;
}
vec4 color = simpleMesh.hasTexture ? texture(sampler, vTexCoord) : vColor;
DECKGL_FILTER_COLOR(color, geometry);
vec3 lightColor = lighting_getLightColor(color.rgb, cameraPosition, position_commonspace.xyz, normal);
fragColor = vec4(lightColor, color.a * layer.opacity);
}
`;function Io(t){switch(t.constructor){case Int8Array:return"int8";case Uint8Array:case Uint8ClampedArray:return"uint8";case Int16Array:return"int16";case Uint16Array:return"uint16";case Int32Array:return"int32";case Uint32Array:return"uint32";case Float32Array:return"float32";case Float64Array:return"float64";default:return"null"}}function Ne(t){let e=1/0,r=1/0,n=1/0,o=-1/0,s=-1/0,i=-1/0,a=t.POSITION?t.POSITION.value:[],c=a&&a.length;for(let f=0;f<c;f+=3){let l=a[f],A=a[f+1],m=a[f+2];e=l<e?l:e,r=A<r?A:r,n=m<n?m:n,o=l>o?l:o,s=A>s?A:s,i=m>i?m:i}return[[e,r,n],[o,s,i]]}function nr(t,e,r){let n=Io(e.value),o=r||So(e);return{name:t,type:{type:"fixed-size-list",listSize:e.size,children:[{name:"value",type:n}]},nullable:!1,metadata:o}}function So(t){let e={};return"byteOffset"in t&&(e.byteOffset=t.byteOffset.toString(10)),"byteStride"in t&&(e.byteStride=t.byteStride.toString(10)),"normalized"in t&&(e.normalized=t.normalized.toString()),e}function or(t){let e=t.positions||t.POSITION;te.log.assert(e,'no "postions" or "POSITION" attribute in mesh');let r=e.value.length/e.size,n=t.COLOR_0||t.colors;n||(n={size:3,value:new Float32Array(r*3).fill(1)});let o=t.NORMAL||t.normals;o||(o={size:3,value:new Float32Array(r*3).fill(0)});let s=t.TEXCOORD_0||t.texCoords;return s||(s={size:2,value:new Float32Array(r*2).fill(0)}),{positions:e,colors:n,normals:o,texCoords:s}}function Fo(t){return t instanceof xe.Geometry?(t.attributes=or(t.attributes),t):t.attributes?new xe.Geometry({...t,topology:"triangle-list",attributes:or(t.attributes)}):new xe.Geometry({topology:"triangle-list",attributes:or(t)})}var Pi=[0,0,0,255],wi={mesh:{type:"object",value:null,async:!0},texture:{type:"image",value:null,async:!0},sizeScale:{type:"number",value:1,min:0},_instanced:!0,wireframe:!1,material:!0,getPosition:{type:"accessor",value:t=>t.position},getColor:{type:"accessor",value:Pi},getOrientation:{type:"accessor",value:[0,0,0]},getScale:{type:"accessor",value:[1,1,1]},getTranslation:{type:"accessor",value:[0,0,0]},getTransformMatrix:{type:"accessor",value:[]},textureParameters:{type:"object",ignore:!0,value:null}},He=class extends te.Layer{getShaders(){return super.getShaders({vs:yo,fs:Ro,modules:[te.project32,mt,te.picking,To]})}getBounds(){if(this.props._instanced)return super.getBounds();let e=this.state.positionBounds;if(e)return e;let{mesh:r}=this.props;if(!r)return null;if(e=r.header?.boundingBox,!e){let{attributes:n}=Fo(r);n.POSITION=n.POSITION||n.positions,e=Ne(n)}return this.state.positionBounds=e,e}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{transition:!0,type:"float64",fp64:this.use64bitPositions(),size:3,accessor:"getPosition"},instanceColors:{type:"unorm8",transition:!0,size:this.props.colorFormat.length,accessor:"getColor",defaultValue:[0,0,0,255]},instanceModelMatrix:ht}),this.setState({emptyTexture:this.context.device.createTexture({data:new Uint8Array(4),width:1,height:1})})}updateState(e){super.updateState(e);let{props:r,oldProps:n,changeFlags:o}=e;if(r.mesh!==n.mesh||o.extensionsChanged){if(this.state.positionBounds=null,this.state.model?.destroy(),r.mesh){this.state.model=this.getModel(r.mesh);let s=r.mesh.attributes||r.mesh;this.setState({hasNormals:Boolean(s.NORMAL||s.normals)})}this.getAttributeManager().invalidateAll()}r.texture!==n.texture&&r.texture instanceof Lo.Texture&&this.setTexture(r.texture),this.state.model&&this.state.model.setTopology(this.props.wireframe?"line-strip":"triangle-list")}finalizeState(e){super.finalizeState(e),this.state.emptyTexture.delete()}draw({uniforms:e}){let{model:r}=this.state;if(!r)return;let{viewport:n,renderPass:o}=this.context,{sizeScale:s,coordinateSystem:i,_instanced:a}=this.props,c={sizeScale:s,composeModelMatrix:!a||ut(n,i),flatShading:!this.state.hasNormals};r.shaderInputs.setProps({simpleMesh:c}),r.draw(o)}get isLoaded(){return Boolean(this.state?.model&&super.isLoaded)}getModel(e){let r=new xe.Model(this.context.device,{...this.getShaders(),id:this.props.id,bufferLayout:this.getAttributeManager().getBufferLayouts(),geometry:Fo(e),isInstanced:!0}),{texture:n}=this.props,{emptyTexture:o}=this.state,s={sampler:n||o,hasTexture:Boolean(n)};return r.shaderInputs.setProps({simpleMesh:s}),r}setTexture(e){let{emptyTexture:r,model:n}=this.state;if(n){let o={sampler:e||r,hasTexture:Boolean(e)};n.shaderInputs.setProps({simpleMesh:o})}}};He.defaultProps=wi;He.layerName="SimpleMeshLayer";var vo=He;var Q=S(pe(),1);var me=S(ve(),1);var Do=S(se(),1);function Oo(t){return{addressModeU:Go(t.wrapS),addressModeV:Go(t.wrapT),magFilter:Ni(t.magFilter),...Hi(t.minFilter)}}function Go(t){switch(t){case 33071:return"clamp-to-edge";case 10497:return"repeat";case 33648:return"mirror-repeat";default:return}}function Ni(t){switch(t){case 9728:return"nearest";case 9729:return"linear";default:return}}function Hi(t){switch(t){case 9728:return{minFilter:"nearest"};case 9729:return{minFilter:"linear"};case 9984:return{minFilter:"nearest",mipmapFilter:"nearest"};case 9985:return{minFilter:"linear",mipmapFilter:"nearest"};case 9986:return{minFilter:"nearest",mipmapFilter:"linear"};case 9987:return{minFilter:"linear",mipmapFilter:"linear"};default:return{}}}function Po(t,e,r,n){let o={defines:{MANUAL_SRGB:!0,SRGB_FAST_APPROXIMATION:!0},bindings:{},uniforms:{camera:[0,0,0],metallicRoughnessValues:[1,1]},parameters:{},glParameters:{},generatedTextures:[]};o.defines.USE_TEX_LOD=!0;let{imageBasedLightingEnvironment:s}=n;return s&&(o.bindings.pbr_diffuseEnvSampler=s.diffuseEnvSampler.texture,o.bindings.pbr_specularEnvSampler=s.specularEnvSampler.texture,o.bindings.pbr_BrdfLUT=s.brdfLutTexture.texture,o.uniforms.scaleIBLAmbient=[1,1]),n?.pbrDebug&&(o.defines.PBR_DEBUG=!0,o.uniforms.scaleDiffBaseMR=[0,0,0,0],o.uniforms.scaleFGDSpec=[0,0,0,0]),r.NORMAL&&(o.defines.HAS_NORMALS=!0),r.TANGENT&&n?.useTangents&&(o.defines.HAS_TANGENTS=!0),r.TEXCOORD_0&&(o.defines.HAS_UV=!0),n?.imageBasedLightingEnvironment&&(o.defines.USE_IBL=!0),n?.lights&&(o.defines.USE_LIGHTS=!0),e&&Ui(t,e,o),o}function Ui(t,e,r){if(r.uniforms.unlit=Boolean(e.unlit),e.pbrMetallicRoughness&&Ji(t,e.pbrMetallicRoughness,r),e.normalTexture){Ue(t,e.normalTexture,"pbr_normalSampler","HAS_NORMALMAP",r);let{scale:n=1}=e.normalTexture;r.uniforms.normalScale=n}if(e.occlusionTexture){Ue(t,e.occlusionTexture,"pbr_occlusionSampler","HAS_OCCLUSIONMAP",r);let{strength:n=1}=e.occlusionTexture;r.uniforms.occlusionStrength=n}switch(e.emissiveTexture&&(Ue(t,e.emissiveTexture,"pbr_emissiveSampler","HAS_EMISSIVEMAP",r),r.uniforms.emissiveFactor=e.emissiveFactor||[0,0,0]),e.alphaMode||"MASK"){case"MASK":let{alphaCutoff:n=.5}=e;r.defines.ALPHA_CUTOFF=!0,r.uniforms.alphaCutoff=n;break;case"BLEND":Do.log.warn("glTF BLEND alphaMode might not work well because it requires mesh sorting")(),r.parameters.blend=!0,r.parameters.blendColorOperation="add",r.parameters.blendColorSrcFactor="src-alpha",r.parameters.blendColorDstFactor="one-minus-src-alpha",r.parameters.blendAlphaOperation="add",r.parameters.blendAlphaSrcFactor="one",r.parameters.blendAlphaDstFactor="one-minus-src-alpha",r.glParameters.blend=!0,r.glParameters.blendEquation=32774,r.glParameters.blendFunc=[770,771,1,771];break}}function Ji(t,e,r){e.baseColorTexture&&Ue(t,e.baseColorTexture,"pbr_baseColorSampler","HAS_BASECOLORMAP",r),r.uniforms.baseColorFactor=e.baseColorFactor||[1,1,1,1],e.metallicRoughnessTexture&&Ue(t,e.metallicRoughnessTexture,"pbr_metallicRoughnessSampler","HAS_METALROUGHNESSMAP",r);let{metallicFactor:n=1,roughnessFactor:o=1}=e;r.uniforms.metallicRoughnessValues=[n,o]}function Ue(t,e,r,n,o){let s=e.texture.source.image,i;s.compressed?i=s:i={data:s};let a={wrapS:10497,wrapT:10497,...e?.texture?.sampler},c=t.createTexture({id:e.uniformName||e.id,sampler:Oo(a),...i});o.bindings[r]=c,n&&(o.defines[n]=!0),o.generatedTextures.push(c)}var Me=S(ve(),1);var ce;(function(t){t[t.POINTS=0]="POINTS",t[t.LINES=1]="LINES",t[t.LINE_LOOP=2]="LINE_LOOP",t[t.LINE_STRIP=3]="LINE_STRIP",t[t.TRIANGLES=4]="TRIANGLES",t[t.TRIANGLE_STRIP=5]="TRIANGLE_STRIP",t[t.TRIANGLE_FAN=6]="TRIANGLE_FAN"})(ce||(ce={}));function wo(t){switch(t){case ce.POINTS:return"point-list";case ce.LINES:return"line-list";case ce.LINE_STRIP:return"line-strip";case ce.TRIANGLES:return"triangle-list";case ce.TRIANGLE_STRIP:return"triangle-strip";default:throw new Error(String(t))}}var No=S(se(),1);var dt=S(ve(),1),Ki=`
layout(0) positions: vec4; // in vec4 POSITION;

  #ifdef HAS_NORMALS
    in vec4 normals; // in vec4 NORMAL;
  #endif

  #ifdef HAS_TANGENTS
    in vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // in vec2 TEXCOORD_0;
    in vec2 texCoords;
  #endif

@vertex
  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = u_MVPMatrix * positions;
  }

@fragment
  out vec4 fragmentColor;

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`,Vi=`#version 300 es

  // in vec4 POSITION;
  in vec4 positions;

  #ifdef HAS_NORMALS
    // in vec4 NORMAL;
    in vec4 normals;
  #endif

  #ifdef HAS_TANGENTS
    in vec4 TANGENT;
  #endif

  #ifdef HAS_UV
    // in vec2 TEXCOORD_0;
    in vec2 texCoords;
  #endif

  void main(void) {
    vec4 _NORMAL = vec4(0.);
    vec4 _TANGENT = vec4(0.);
    vec2 _TEXCOORD_0 = vec2(0.);

    #ifdef HAS_NORMALS
      _NORMAL = normals;
    #endif

    #ifdef HAS_TANGENTS
      _TANGENT = TANGENT;
    #endif

    #ifdef HAS_UV
      _TEXCOORD_0 = texCoords;
    #endif

    pbr_setPositionNormalTangentUV(positions, _NORMAL, _TANGENT, _TEXCOORD_0);
    gl_Position = pbrProjection.modelViewProjectionMatrix * positions;
  }
`,Xi=`#version 300 es
  out vec4 fragmentColor;

  void main(void) {
    vec3 pos = pbr_vPosition;
    fragmentColor = pbr_filterColor(vec4(1.0));
  }
`;function Ho(t,e){let{id:r,geometry:n,parsedPPBRMaterial:o,vertexCount:s,modelOptions:i={}}=e;No.log.info(4,"createGLTFModel defines: ",o.defines)();let a=[],c={depthWriteEnabled:!0,depthCompare:"less",depthFormat:"depth24plus",cullMode:"back"},f={id:r,source:Ki,vs:Vi,fs:Xi,geometry:n,topology:n.topology,vertexCount:s,modules:[we],...i,defines:{...o.defines,...i.defines},parameters:{...c,...o.parameters,...i.parameters}},l=new dt.Model(t,f),{camera:A,...m}={...o.uniforms,...i.uniforms,...o.bindings,...i.bindings};return l.shaderInputs.setProps({pbrMaterial:m,pbrProjection:{camera:A}}),new dt.ModelNode({managedResources:a,model:l})}var ji={modelOptions:{},pbrDebug:!1,imageBasedLightingEnvironment:void 0,lights:!0,useTangents:!1};function Jo(t,e,r={}){let n={...ji,...r};return e.scenes.map(s=>ki(t,s,e.nodes,n))}function ki(t,e,r,n){let s=(e.nodes||[]).map(a=>Ko(t,a,r,n));return new Me.GroupNode({id:e.name||e.id,children:s})}function Ko(t,e,r,n){if(!e._node){let i=(e.children||[]).map(c=>Ko(t,c,r,n));e.mesh&&i.push(Qi(t,e.mesh,n));let a=new Me.GroupNode({id:e.name||e.id,children:i});if(e.matrix)a.setMatrix(e.matrix);else{if(a.matrix.identity(),e.translation&&a.matrix.translate(e.translation),e.rotation){let c=new W().fromQuaternion(e.rotation);a.matrix.multiplyRight(c)}e.scale&&a.matrix.scale(e.scale)}e._node=a}let o=r.find(s=>s.id===e.id);return o._node=e._node,e._node}function Qi(t,e,r){if(!e._mesh){let o=(e.primitives||[]).map((i,a)=>zi(t,i,a,e,r)),s=new Me.GroupNode({id:e.name||e.id,children:o});e._mesh=s}return e._mesh}function zi(t,e,r,n,o){let s=e.name||`${n.name||n.id}-primitive-${r}`,i=wo(e.mode||4),a=e.indices?e.indices.count:Yi(e.attributes),c=Uo(s,e,i),f=Po(t,e.material,c.attributes,o),l=Ho(t,{id:s,geometry:Uo(s,e,i),parsedPPBRMaterial:f,modelOptions:o.modelOptions,vertexCount:a});return l.bounds=[e.attributes.POSITION.min,e.attributes.POSITION.max],l}function Yi(t){throw new Error("getVertexCount not implemented")}function Uo(t,e,r){let n={};for(let[o,s]of Object.entries(e.attributes)){let{components:i,size:a,value:c}=s;n[o]={size:a??i,value:c}}return new Me.Geometry({id:t,topology:r,indices:e.indices.value,attributes:n})}var Xo=S(se(),1);var ir=S(se(),1);var sr=new De;function Vo(t,{input:e,interpolation:r,output:n},o,s){let i=e[e.length-1],a=t%i,c=e.findIndex(m=>m>=a),f=Math.max(0,c-1);if(!Array.isArray(o[s]))switch(s){case"translation":o[s]=[0,0,0];break;case"rotation":o[s]=[0,0,0,1];break;case"scale":o[s]=[1,1,1];break;default:ir.log.warn(`Bad animation path ${s}`)()}let l=e[f],A=e[c];switch(r){case"STEP":Zi(o,s,n[f]);break;case"LINEAR":if(A>l){let m=(a-l)/(A-l);Wi(o,s,n[f],n[c],m)}break;case"CUBICSPLINE":if(A>l){let m=(a-l)/(A-l),p=A-l,h=n[3*f+1],u=n[3*f+2],g=n[3*c+0],B=n[3*c+1];qi(o,s,{p0:h,outTangent0:u,inTangent1:g,p1:B,tDiff:p,ratio:m})}break;default:ir.log.warn(`Interpolation ${r} not supported`)();break}}function Wi(t,e,r,n,o){if(!t[e])throw new Error;if(e==="rotation"){sr.slerp({start:r,target:n,ratio:o});for(let s=0;s<sr.length;s++)t[e][s]=sr[s]}else for(let s=0;s<r.length;s++)t[e][s]=o*n[s]+(1-o)*r[s]}function qi(t,e,{p0:r,outTangent0:n,inTangent1:o,p1:s,tDiff:i,ratio:a}){if(!t[e])throw new Error;for(let c=0;c<t[e].length;c++){let f=n[c]*i,l=o[c]*i;t[e][c]=(2*Math.pow(a,3)-3*Math.pow(a,2)+1)*r[c]+(Math.pow(a,3)-2*Math.pow(a,2)+a)*f+(-2*Math.pow(a,3)+3*Math.pow(a,2))*s[c]+(Math.pow(a,3)-Math.pow(a,2))*l}}function Zi(t,e,r){if(!t[e])throw new Error;for(let n=0;n<r.length;n++)t[e][n]=r[n]}var ar=class{animation;startTime=0;playing=!0;speed=1;constructor(e){this.animation=e.animation,this.animation.name||="unnamed",Object.assign(this,e)}setTime(e){if(!this.playing)return;let n=(e/1e3-this.startTime)*this.speed;this.animation.channels.forEach(({sampler:o,target:s,path:i})=>{Vo(n,o,s,i),ea(s,s._node)})}},gt=class{animations;constructor(e){this.animations=e.animations.map((r,n)=>{let o=r.name||`Animation-${n}`;return new ar({animation:{name:o,channels:r.channels}})})}animate(e){Xo.log.warn("GLTFAnimator#animate is deprecated. Use GLTFAnimator#setTime instead")(),this.setTime(e)}setTime(e){this.animations.forEach(r=>r.setTime(e))}getAnimations(){return this.animations}},$i=new W;function ea(t,e){if(e.matrix.identity(),t.translation&&e.matrix.translate(t.translation),t.rotation){let r=$i.fromQuaternion(t.rotation);e.matrix.multiplyRight(r)}t.scale&&e.matrix.scale(t.scale)}var ta={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},ra={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array};function jo(t){let e=ra[t.componentType],r=ta[t.type],n=r*t.count,{buffer:o,byteOffset:s=0}=t.bufferView?.data??{};return{typedArray:new e(o,s+(t.byteOffset||0),n),components:r}}function Qo(t){return(t.animations||[]).map((r,n)=>{let o=r.name||`Animation-${n}`,s=r.samplers.map(({input:a,interpolation:c="LINEAR",output:f})=>({input:ko(t.accessors[a]),interpolation:c,output:ko(t.accessors[f])})),i=r.channels.map(({sampler:a,target:c})=>({sampler:s[a],target:t.nodes[c.node??0],path:c.path}));return{name:o,channels:i}})}function ko(t){if(!t._animation){let{typedArray:e,components:r}=jo(t);if(r===1)t._animation=Array.from(e);else{let n=[];for(let o=0;o<e.length;o+=r)n.push(Array.from(e.slice(o,o+r)));t._animation=n}}return t._animation}function Bt(t){if(ArrayBuffer.isView(t)||t instanceof ArrayBuffer||t instanceof ImageBitmap)return t;if(Array.isArray(t))return t.map(Bt);if(t&&typeof t=="object"){let e={};for(let r in t)e[r]=Bt(t[r]);return e}return t}function cr(t,e,r){e=Bt(e);let n=Jo(t,e,r),o=Qo(e),s=new gt({animations:o});return{scenes:n,animator:s}}var Mr={};P(Mr,{createExtMeshFeatures:()=>ec,decode:()=>Ya,encode:()=>Wa,name:()=>za});var zo="4.3.3";async function Je(t,e,r,n){return n._parse(t,e,r,n)}function w(t,e){if(!t)throw new Error(e||"loader assertion failed.")}var V={self:typeof self<"u"&&self,window:typeof window<"u"&&window,global:typeof global<"u"&&global,document:typeof document<"u"&&document},na=V.self||V.window||V.global||{},oa=V.window||V.self||V.global||{},sa=V.global||V.self||V.window||{},ia=V.document||{};var Ke=Boolean(typeof process!="object"||String(process)!=="[object process]"||process.browser);var Yo=typeof process<"u"&&process.version&&/v([0-9]*)/.exec(process.version),aa=Yo&&parseFloat(Yo[1])||0;function fr(t){globalThis.loaders||={},globalThis.loaders.modules||={},Object.assign(globalThis.loaders.modules,t)}function lr(t){return globalThis.loaders?.modules?.[t]||null}function ca(){return globalThis._loadersgl_?.version||(globalThis._loadersgl_=globalThis._loadersgl_||{},globalThis._loadersgl_.version="4.3.3"),globalThis._loadersgl_.version}var Wo=ca();function qo(t,e){if(!t)throw new Error(e||"loaders.gl assertion failed.")}var X={self:typeof self<"u"&&self,window:typeof window<"u"&&window,global:typeof global<"u"&&global,document:typeof document<"u"&&document},Ep=X.self||X.window||X.global||{},bp=X.window||X.self||X.global||{},_p=X.global||X.self||X.window||{},Tp=X.document||{};var Ee=typeof process!="object"||String(process)!=="[object process]"||process.browser,Ct=typeof importScripts=="function",yp=typeof window<"u"&&typeof window.orientation<"u",Zo=typeof process<"u"&&process.version&&/v([0-9]*)/.exec(process.version),Rp=Zo&&parseFloat(Zo[1])||0;var Ar={};async function j(t,e=null,r={},n=null){return e&&(t=$o(t,e,r,n)),Ar[t]=Ar[t]||fa(t),await Ar[t]}function $o(t,e,r={},n=null){if(!r.useLocalLibraries&&t.startsWith("http"))return t;n=n||t;let o=r.modules||{};return o[n]?o[n]:Ee?r.CDN?(qo(r.CDN.startsWith("http")),`${r.CDN}/${e}@${Wo}/dist/libs/${n}`):Ct?`../src/libs/${n}`:`modules/${e}/src/libs/${n}`:`modules/${e}/dist/libs/${n}`}async function fa(t){if(t.endsWith("wasm"))return await Aa(t);if(!Ee)try{let{requireFromFile:r}=globalThis.loaders||{};return await r?.(t)}catch(r){return console.error(r),null}if(Ct)return importScripts(t);let e=await ma(t);return la(e,t)}function la(t,e){if(!Ee){let{requireFromString:n}=globalThis.loaders||{};return n?.(t,e)}if(Ct)return eval.call(globalThis,t),null;let r=document.createElement("script");r.id=e;try{r.appendChild(document.createTextNode(t))}catch{r.text=t}return document.body.appendChild(r),null}async function Aa(t){let{readFileAsArrayBuffer:e}=globalThis.loaders||{};return Ee||!e||t.startsWith("http")?await(await fetch(t)).arrayBuffer():await e(t)}async function ma(t){let{readFileAsText:e}=globalThis.loaders||{};return Ee||!e||t.startsWith("http")?await(await fetch(t)).text():await e(t)}function ts(t,e=5){return typeof t=="string"?t.slice(0,e):ArrayBuffer.isView(t)?es(t.buffer,t.byteOffset,e):t instanceof ArrayBuffer?es(t,0,e):""}function es(t,e,r){if(t.byteLength<=e+r)return"";let n=new DataView(t),o="";for(let s=0;s<r;s++)o+=String.fromCharCode(n.getUint8(e+s));return o}function mr(t){try{return JSON.parse(t)}catch{throw new Error(`Failed to parse JSON from data starting with "${ts(t)}"`)}}function Ve(t,e,r){let n=r!==void 0?new Uint8Array(t).subarray(e,e+r):new Uint8Array(t).subarray(e);return new Uint8Array(n).buffer}function re(t,e){return w(t>=0),w(e>0),t+(e-1)&~(e-1)}function pr(t,e,r){let n;if(t instanceof ArrayBuffer)n=new Uint8Array(t);else{let o=t.byteOffset,s=t.byteLength;n=new Uint8Array(t.buffer||t.arrayBuffer,o,s)}return e.set(n,r),r+re(n.byteLength,4)}var pa=globalThis.loaders?.parseImageNode,hr=typeof Image<"u",ur=typeof ImageBitmap<"u",ha=Boolean(pa),dr=Ke?!0:ha;function rs(t){switch(t){case"auto":return ur||hr||dr;case"imagebitmap":return ur;case"image":return hr;case"data":return dr;default:throw new Error(`@loaders.gl/images: image ${t} not supported in this environment`)}}function ns(){if(ur)return"imagebitmap";if(hr)return"image";if(dr)return"data";throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js")}function os(t){let e=ua(t);if(!e)throw new Error("Not an image");return e}function Xe(t){switch(os(t)){case"data":return t;case"image":case"imagebitmap":let e=document.createElement("canvas"),r=e.getContext("2d");if(!r)throw new Error("getImageData");return e.width=t.width,e.height=t.height,r.drawImage(t,0,0),r.getImageData(0,0,t.width,t.height);default:throw new Error("getImageData")}}function ua(t){return typeof ImageBitmap<"u"&&t instanceof ImageBitmap?"imagebitmap":typeof Image<"u"&&t instanceof Image?"image":t&&typeof t=="object"&&t.data&&t.width&&t.height?"data":null}var da=/^data:image\/svg\+xml/,ga=/\.svg((\?|#).*)?$/;function xt(t){return t&&(da.test(t)||ga.test(t))}function ss(t,e){if(xt(e)){let n=new TextDecoder().decode(t);try{typeof unescape=="function"&&typeof encodeURIComponent=="function"&&(n=unescape(encodeURIComponent(n)))}catch(s){throw new Error(s.message)}return`data:image/svg+xml;base64,${btoa(n)}`}return gr(t,e)}function gr(t,e){if(xt(e))throw new Error("SVG cannot be parsed directly to imagebitmap");return new Blob([new Uint8Array(t)])}async function Mt(t,e,r){let n=ss(t,r),o=self.URL||self.webkitURL,s=typeof n!="string"&&o.createObjectURL(n);try{return await Ba(s||n,e)}finally{s&&o.revokeObjectURL(s)}}async function Ba(t,e){let r=new Image;return r.src=t,e.image&&e.image.decode&&r.decode?(await r.decode(),r):await new Promise((n,o)=>{try{r.onload=()=>n(r),r.onerror=s=>{let i=s instanceof Error?s.message:"error";o(new Error(i))}}catch(s){o(s)}})}var Ca={},is=!0;async function as(t,e,r){let n;xt(r)?n=await Mt(t,e,r):n=gr(t,r);let o=e&&e.imagebitmap;return await xa(n,o)}async function xa(t,e=null){if((Ma(e)||!is)&&(e=null),e)try{return await createImageBitmap(t,e)}catch(r){console.warn(r),is=!1}return await createImageBitmap(t)}function Ma(t){for(let e in t||Ca)return!1;return!0}function cs(t){return!Ta(t,"ftyp",4)||!(t[8]&96)?null:Ea(t)}function Ea(t){switch(ba(t,8,12).replace("\0"," ").trim()){case"avif":case"avis":return{extension:"avif",mimeType:"image/avif"};default:return null}}function ba(t,e,r){return String.fromCharCode(...t.slice(e,r))}function _a(t){return[...t].map(e=>e.charCodeAt(0))}function Ta(t,e,r=0){let n=_a(e);for(let o=0;o<n.length;++o)if(n[o]!==t[o+r])return!1;return!0}var k=!1,je=!0;function fe(t){let e=ke(t);return Ra(e)||Fa(e)||Ia(e)||Sa(e)||ya(e)}function ya(t){let e=new Uint8Array(t instanceof DataView?t.buffer:t),r=cs(e);return r?{mimeType:r.mimeType,width:0,height:0}:null}function Ra(t){let e=ke(t);return e.byteLength>=24&&e.getUint32(0,k)===2303741511?{mimeType:"image/png",width:e.getUint32(16,k),height:e.getUint32(20,k)}:null}function Ia(t){let e=ke(t);return e.byteLength>=10&&e.getUint32(0,k)===1195984440?{mimeType:"image/gif",width:e.getUint16(6,je),height:e.getUint16(8,je)}:null}function Sa(t){let e=ke(t);return e.byteLength>=14&&e.getUint16(0,k)===16973&&e.getUint32(2,je)===e.byteLength?{mimeType:"image/bmp",width:e.getUint32(18,je),height:e.getUint32(22,je)}:null}function Fa(t){let e=ke(t);if(!(e.byteLength>=3&&e.getUint16(0,k)===65496&&e.getUint8(2)===255))return null;let{tableMarkers:n,sofMarkers:o}=La(),s=2;for(;s+9<e.byteLength;){let i=e.getUint16(s,k);if(o.has(i))return{mimeType:"image/jpeg",height:e.getUint16(s+5,k),width:e.getUint16(s+7,k)};if(!n.has(i))return null;s+=2,s+=e.getUint16(s,k)}return null}function La(){let t=new Set([65499,65476,65484,65501,65534]);for(let r=65504;r<65520;++r)t.add(r);return{tableMarkers:t,sofMarkers:new Set([65472,65473,65474,65475,65477,65478,65479,65481,65482,65483,65485,65486,65487,65502])}}function ke(t){if(t instanceof DataView)return t;if(ArrayBuffer.isView(t))return new DataView(t.buffer);if(t instanceof ArrayBuffer)return new DataView(t);throw new Error("toDataView")}async function fs(t,e){let{mimeType:r}=fe(t)||{},n=globalThis.loaders?.parseImageNode;return w(n),await n(t,r)}async function ls(t,e,r){e=e||{};let o=(e.image||{}).type||"auto",{url:s}=r||{},i=va(o),a;switch(i){case"imagebitmap":a=await as(t,e,s);break;case"image":a=await Mt(t,e,s);break;case"data":a=await fs(t,e);break;default:w(!1)}return o==="data"&&(a=Xe(a)),a}function va(t){switch(t){case"auto":case"data":return ns();default:return rs(t),t}}var Ga=["png","jpg","jpeg","gif","webp","bmp","ico","svg","avif"],Oa=["image/png","image/jpeg","image/gif","image/webp","image/avif","image/bmp","image/vnd.microsoft.icon","image/svg+xml"],Da={image:{type:"auto",decode:!0}},Br={dataType:null,batchType:null,id:"image",module:"images",name:"Images",version:zo,mimeTypes:Oa,extensions:Ga,parse:ls,tests:[t=>Boolean(fe(new DataView(t)))],options:Da};var Cr={};function xr(t){if(Cr[t]===void 0){let e=Ke?wa(t):Pa(t);Cr[t]=e}return Cr[t]}function Pa(t){let e=["image/png","image/jpeg","image/gif"],r=globalThis.loaders?.imageFormatsNode||e,n=globalThis.loaders?.parseImageNode;return Boolean(n)&&r.includes(t)}function wa(t){switch(t){case"image/avif":case"image/webp":return Na(t);default:return!0}}function Na(t){try{return document.createElement("canvas").toDataURL(t).indexOf(`data:${t}`)===0}catch{return!1}}function R(t,e){if(!t)throw new Error(e||"assert failed: gltf")}var Et={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},bt={5120:1,5121:1,5122:2,5123:2,5125:4,5126:4};var As=["SCALAR","VEC2","VEC3","VEC4"],Ha=[[Int8Array,5120],[Uint8Array,5121],[Int16Array,5122],[Uint16Array,5123],[Uint32Array,5125],[Float32Array,5126],[Float64Array,5130]],Ua=new Map(Ha),Ja={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Ka={5120:1,5121:1,5122:2,5123:2,5125:4,5126:4},Va={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array};function _t(t){return As[t-1]||As[0]}function ne(t){let e=Ua.get(t.constructor);if(!e)throw new Error("Illegal typed array");return e}function be(t,e){let r=Va[t.componentType],n=Ja[t.type],o=Ka[t.componentType],s=t.count*n,i=t.count*n*o;R(i>=0&&i<=e.byteLength);let a=bt[t.componentType],c=Et[t.type];return{ArrayType:r,length:s,byteLength:i,componentByteSize:a,numberOfComponentsInElement:c}}function ms(t,e,r){let n=t.bufferViews[r];R(n);let o=n.buffer,s=e[o];R(s);let i=(n.byteOffset||0)+s.byteOffset;return new Uint8Array(s.arrayBuffer,i,n.byteLength)}function ps(t,e,r){let n=typeof r=="number"?t.accessors?.[r]:r;if(!n)throw new Error(`No gltf accessor ${JSON.stringify(r)}`);let o=t.bufferViews?.[n.bufferView||0];if(!o)throw new Error(`No gltf buffer view for accessor ${o}`);let{arrayBuffer:s,byteOffset:i}=e[o.buffer],a=(i||0)+(n.byteOffset||0)+(o.byteOffset||0),{ArrayType:c,length:f,componentByteSize:l,numberOfComponentsInElement:A}=be(n,o),m=l*A,p=o.byteStride||m;if(typeof o.byteStride>"u"||o.byteStride===m)return new c(s,a,f);let h=new c(f);for(let u=0;u<n.count;u++){let g=new c(s,a+u*p,A);h.set(g,u*A)}return h}function Xa(){return{asset:{version:"2.0",generator:"loaders.gl"},buffers:[],extensions:{},extensionsRequired:[],extensionsUsed:[]}}var _=class{gltf;sourceBuffers;byteLength;constructor(e){this.gltf={json:e?.json||Xa(),buffers:e?.buffers||[],images:e?.images||[]},this.sourceBuffers=[],this.byteLength=0,this.gltf.buffers&&this.gltf.buffers[0]&&(this.byteLength=this.gltf.buffers[0].byteLength,this.sourceBuffers=[this.gltf.buffers[0]])}get json(){return this.gltf.json}getApplicationData(e){return this.json[e]}getExtraData(e){return(this.json.extras||{})[e]}hasExtension(e){let r=this.getUsedExtensions().find(o=>o===e),n=this.getRequiredExtensions().find(o=>o===e);return typeof r=="string"||typeof n=="string"}getExtension(e){let r=this.getUsedExtensions().find(o=>o===e),n=this.json.extensions||{};return r?n[e]:null}getRequiredExtension(e){return this.getRequiredExtensions().find(n=>n===e)?this.getExtension(e):null}getRequiredExtensions(){return this.json.extensionsRequired||[]}getUsedExtensions(){return this.json.extensionsUsed||[]}getRemovedExtensions(){return this.json.extensionsRemoved||[]}getObjectExtension(e,r){return(e.extensions||{})[r]}getScene(e){return this.getObject("scenes",e)}getNode(e){return this.getObject("nodes",e)}getSkin(e){return this.getObject("skins",e)}getMesh(e){return this.getObject("meshes",e)}getMaterial(e){return this.getObject("materials",e)}getAccessor(e){return this.getObject("accessors",e)}getTexture(e){return this.getObject("textures",e)}getSampler(e){return this.getObject("samplers",e)}getImage(e){return this.getObject("images",e)}getBufferView(e){return this.getObject("bufferViews",e)}getBuffer(e){return this.getObject("buffers",e)}getObject(e,r){if(typeof r=="object")return r;let n=this.json[e]&&this.json[e][r];if(!n)throw new Error(`glTF file error: Could not find ${e}[${r}]`);return n}getTypedArrayForBufferView(e){e=this.getBufferView(e);let r=e.buffer,n=this.gltf.buffers[r];R(n);let o=(e.byteOffset||0)+n.byteOffset;return new Uint8Array(n.arrayBuffer,o,e.byteLength)}getTypedArrayForAccessor(e){let r=this.getAccessor(e);return ps(this.gltf.json,this.gltf.buffers,r)}getTypedArrayForImageData(e){e=this.getAccessor(e);let r=this.getBufferView(e.bufferView),o=this.getBuffer(r.buffer).data,s=r.byteOffset||0;return new Uint8Array(o,s,r.byteLength)}addApplicationData(e,r){return this.json[e]=r,this}addExtraData(e,r){return this.json.extras=this.json.extras||{},this.json.extras[e]=r,this}addObjectExtension(e,r,n){return e.extensions=e.extensions||{},e.extensions[r]=n,this.registerUsedExtension(r),this}setObjectExtension(e,r,n){let o=e.extensions||{};o[r]=n}removeObjectExtension(e,r){let n=e?.extensions||{};if(n[r]){this.json.extensionsRemoved=this.json.extensionsRemoved||[];let o=this.json.extensionsRemoved;o.includes(r)||o.push(r)}delete n[r]}addExtension(e,r={}){return R(r),this.json.extensions=this.json.extensions||{},this.json.extensions[e]=r,this.registerUsedExtension(e),r}addRequiredExtension(e,r={}){return R(r),this.addExtension(e,r),this.registerRequiredExtension(e),r}registerUsedExtension(e){this.json.extensionsUsed=this.json.extensionsUsed||[],this.json.extensionsUsed.find(r=>r===e)||this.json.extensionsUsed.push(e)}registerRequiredExtension(e){this.registerUsedExtension(e),this.json.extensionsRequired=this.json.extensionsRequired||[],this.json.extensionsRequired.find(r=>r===e)||this.json.extensionsRequired.push(e)}removeExtension(e){if(this.json.extensions?.[e]){this.json.extensionsRemoved=this.json.extensionsRemoved||[];let r=this.json.extensionsRemoved;r.includes(e)||r.push(e)}this.json.extensions&&delete this.json.extensions[e],this.json.extensionsRequired&&this._removeStringFromArray(this.json.extensionsRequired,e),this.json.extensionsUsed&&this._removeStringFromArray(this.json.extensionsUsed,e)}setDefaultScene(e){this.json.scene=e}addScene(e){let{nodeIndices:r}=e;return this.json.scenes=this.json.scenes||[],this.json.scenes.push({nodes:r}),this.json.scenes.length-1}addNode(e){let{meshIndex:r,matrix:n}=e;this.json.nodes=this.json.nodes||[];let o={mesh:r};return n&&(o.matrix=n),this.json.nodes.push(o),this.json.nodes.length-1}addMesh(e){let{attributes:r,indices:n,material:o,mode:s=4}=e,a={primitives:[{attributes:this._addAttributes(r),mode:s}]};if(n){let c=this._addIndices(n);a.primitives[0].indices=c}return Number.isFinite(o)&&(a.primitives[0].material=o),this.json.meshes=this.json.meshes||[],this.json.meshes.push(a),this.json.meshes.length-1}addPointCloud(e){let n={primitives:[{attributes:this._addAttributes(e),mode:0}]};return this.json.meshes=this.json.meshes||[],this.json.meshes.push(n),this.json.meshes.length-1}addImage(e,r){let n=fe(e),o=r||n?.mimeType,i={bufferView:this.addBufferView(e),mimeType:o};return this.json.images=this.json.images||[],this.json.images.push(i),this.json.images.length-1}addBufferView(e,r=0,n=this.byteLength){let o=e.byteLength;R(Number.isFinite(o)),this.sourceBuffers=this.sourceBuffers||[],this.sourceBuffers.push(e);let s={buffer:r,byteOffset:n,byteLength:o};return this.byteLength+=re(o,4),this.json.bufferViews=this.json.bufferViews||[],this.json.bufferViews.push(s),this.json.bufferViews.length-1}addAccessor(e,r){let n={bufferView:e,type:_t(r.size),componentType:r.componentType,count:r.count,max:r.max,min:r.min};return this.json.accessors=this.json.accessors||[],this.json.accessors.push(n),this.json.accessors.length-1}addBinaryBuffer(e,r={size:3}){let n=this.addBufferView(e),o={min:r.min,max:r.max};(!o.min||!o.max)&&(o=this._getAccessorMinMax(e,r.size));let s={size:r.size,componentType:ne(e),count:Math.round(e.length/r.size),min:o.min,max:o.max};return this.addAccessor(n,Object.assign(s,r))}addTexture(e){let{imageIndex:r}=e,n={source:r};return this.json.textures=this.json.textures||[],this.json.textures.push(n),this.json.textures.length-1}addMaterial(e){return this.json.materials=this.json.materials||[],this.json.materials.push(e),this.json.materials.length-1}createBinaryChunk(){let e=this.byteLength,r=new ArrayBuffer(e),n=new Uint8Array(r),o=0;for(let s of this.sourceBuffers||[])o=pr(s,n,o);this.json?.buffers?.[0]?this.json.buffers[0].byteLength=e:this.json.buffers=[{byteLength:e}],this.gltf.binary=r,this.sourceBuffers=[r],this.gltf.buffers=[{arrayBuffer:r,byteOffset:0,byteLength:r.byteLength}]}_removeStringFromArray(e,r){let n=!0;for(;n;){let o=e.indexOf(r);o>-1?e.splice(o,1):n=!1}}_addAttributes(e={}){let r={};for(let n in e){let o=e[n],s=this._getGltfAttributeName(n),i=this.addBinaryBuffer(o.value,o);r[s]=i}return r}_addIndices(e){return this.addBinaryBuffer(e,{size:1})}_getGltfAttributeName(e){switch(e.toLowerCase()){case"position":case"positions":case"vertices":return"POSITION";case"normal":case"normals":return"NORMAL";case"color":case"colors":return"COLOR_0";case"texcoord":case"texcoords":return"TEXCOORD_0";default:return e}}_getAccessorMinMax(e,r){let n={min:null,max:null};if(e.length<r)return n;n.min=[],n.max=[];let o=e.subarray(0,r);for(let s of o)n.min.push(s),n.max.push(s);for(let s=r;s<e.length;s+=r)for(let i=0;i<r;i++)n.min[0+i]=Math.min(n.min[0+i],e[s+i]),n.max[0+i]=Math.max(n.max[0+i],e[s+i]);return n}};function hs(t){return(t%1+1)%1}var us={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16,BOOLEAN:1,STRING:1,ENUM:1},ja={INT8:Int8Array,UINT8:Uint8Array,INT16:Int16Array,UINT16:Uint16Array,INT32:Int32Array,UINT32:Uint32Array,INT64:BigInt64Array,UINT64:BigUint64Array,FLOAT32:Float32Array,FLOAT64:Float64Array},ds={INT8:1,UINT8:1,INT16:2,UINT16:2,INT32:4,UINT32:4,INT64:8,UINT64:8,FLOAT32:4,FLOAT64:8};function Qe(t,e){return ds[e]*us[t]}function _e(t,e,r,n){if(r!=="UINT8"&&r!=="UINT16"&&r!=="UINT32"&&r!=="UINT64")return null;let o=t.getTypedArrayForBufferView(e),s=Te(o,"SCALAR",r,n+1);return s instanceof BigInt64Array||s instanceof BigUint64Array?null:s}function Te(t,e,r,n=1){let o=us[e],s=ja[r],i=ds[r],a=n*o,c=a*i,f=t.buffer,l=t.byteOffset;return l%i!==0&&(f=new Uint8Array(f).slice(l,l+c).buffer,l=0),new s(f,l,a)}function ye(t,e,r){let n=`TEXCOORD_${e.texCoord||0}`,o=r.attributes[n],s=t.getTypedArrayForAccessor(o),i=t.gltf.json,a=e.index,c=i.textures?.[a]?.source;if(typeof c<"u"){let f=i.images?.[c]?.mimeType,l=t.gltf.images?.[c];if(l&&typeof l.width<"u"){let A=[];for(let m=0;m<s.length;m+=2){let p=ka(l,f,s,m,e.channels);A.push(p)}return A}}return[]}function Tt(t,e,r,n,o){if(!r?.length)return;let s=[];for(let l of r){let A=n.findIndex(m=>m===l);A===-1&&(A=n.push(l)-1),s.push(A)}let i=new Uint32Array(s),a=t.gltf.buffers.push({arrayBuffer:i.buffer,byteOffset:i.byteOffset,byteLength:i.byteLength})-1,c=t.addBufferView(i,a,0),f=t.addAccessor(c,{size:1,componentType:ne(i),count:i.length});o.attributes[e]=f}function ka(t,e,r,n,o=[0]){let s={r:{offset:0,shift:0},g:{offset:1,shift:8},b:{offset:2,shift:16},a:{offset:3,shift:24}},i=r[n],a=r[n+1],c=1;e&&(e.indexOf("image/jpeg")!==-1||e.indexOf("image/png")!==-1)&&(c=4);let f=Qa(i,a,t,c),l=0;for(let A of o){let m=typeof A=="number"?Object.values(s)[A]:s[A],p=f+m.offset,h=Xe(t);if(h.data.length<=p)throw new Error(`${h.data.length} <= ${p}`);let u=h.data[p];l|=u<<m.shift}return l}function Qa(t,e,r,n=1){let o=r.width,s=hs(t)*(o-1),i=Math.round(s),a=r.height,c=hs(e)*(a-1),f=Math.round(c),l=r.components?r.components:n;return(f*o+i)*l}function yt(t,e,r,n,o){let s=[];for(let i=0;i<e;i++){let a=r[i],c=r[i+1]-r[i];if(c+a>n)break;let f=a/o,l=c/o;s.push(t.slice(f,f+l))}return s}function Rt(t,e,r){let n=[];for(let o=0;o<e;o++){let s=o*r;n.push(t.slice(s,s+r))}return n}function It(t,e,r,n){if(r)throw new Error("Not implemented - arrayOffsets for strings is specified");if(n){let o=[],s=new TextDecoder("utf8"),i=0;for(let a=0;a<t;a++){let c=n[a+1]-n[a];if(c+i<=e.length){let f=e.subarray(i,c+i),l=s.decode(f);o.push(l),i+=c}}return o}return[]}var Re="EXT_mesh_features",za=Re;async function Ya(t,e){let r=new _(t);qa(r,e)}function Wa(t,e){let r=new _(t);return $a(r,e),r.createBinaryChunk(),r.gltf}function qa(t,e){let r=t.gltf.json;if(r.meshes)for(let n of r.meshes)for(let o of n.primitives)Za(t,o,e)}function Za(t,e,r){if(!r?.gltf?.loadBuffers)return;let o=e.extensions?.[Re]?.featureIds;if(o)for(let s of o){let i;if(typeof s.attribute<"u"){let a=`_FEATURE_ID_${s.attribute}`,c=e.attributes[a];i=t.getTypedArrayForAccessor(c)}else typeof s.texture<"u"&&r?.gltf?.loadImages?i=ye(t,s.texture,e):i=[];s.data=i}}function $a(t,e){let r=t.gltf.json.meshes;if(r)for(let n of r)for(let o of n.primitives)tc(t,o)}function ec(t,e,r,n){e.extensions||(e.extensions={});let o=e.extensions[Re];o||(o={featureIds:[]},e.extensions[Re]=o);let{featureIds:s}=o,i={featureCount:r.length,propertyTable:n,data:r};s.push(i),t.addObjectExtension(e,Re,o)}function tc(t,e){let r=e.extensions?.[Re];if(!r)return;let n=r.featureIds;n.forEach((o,s)=>{if(o.data){let{accessorKey:i,index:a}=rc(e.attributes),c=new Uint32Array(o.data);n[s]={featureCount:c.length,propertyTable:o.propertyTable,attribute:a},t.gltf.buffers.push({arrayBuffer:c.buffer,byteOffset:c.byteOffset,byteLength:c.byteLength});let f=t.addBufferView(c),l=t.addAccessor(f,{size:1,componentType:ne(c),count:c.length});e.attributes[i]=l}})}function rc(t){let e="_FEATURE_ID_",r=Object.keys(t).filter(s=>s.indexOf(e)===0),n=-1;for(let s of r){let i=Number(s.substring(e.length));i>n&&(n=i)}return n++,{accessorKey:`${e}${n}`,index:n}}var _r={};P(_r,{createExtStructuralMetadata:()=>_c,decode:()=>oc,encode:()=>sc,name:()=>nc});var Ie="EXT_structural_metadata",nc=Ie;async function oc(t,e){let r=new _(t);ic(r,e)}function sc(t,e){let r=new _(t);return Ec(r,e),r.createBinaryChunk(),r.gltf}function ic(t,e){if(!e.gltf?.loadBuffers)return;let r=t.getExtension(Ie);r&&(e.gltf?.loadImages&&ac(t,r),cc(t,r))}function ac(t,e){let r=e.propertyTextures,n=t.gltf.json;if(r&&n.meshes)for(let o of n.meshes)for(let s of o.primitives)lc(t,r,s,e)}function cc(t,e){let r=e.schema;if(!r)return;let n=r.classes,o=e.propertyTables;if(n&&o)for(let s in n){let i=fc(o,s);i&&mc(t,r,i)}}function fc(t,e){for(let r of t)if(r.class===e)return r;return null}function lc(t,e,r,n){if(!e)return;let s=r.extensions?.[Ie]?.propertyTextures;if(s)for(let i of s){let a=e[i];Ac(t,a,r,n)}}function Ac(t,e,r,n){if(!e.properties)return;n.dataAttributeNames||(n.dataAttributeNames=[]);let o=e.class;for(let s in e.properties){let i=`${o}_${s}`,a=e.properties?.[s];if(!a)continue;a.data||(a.data=[]);let c=a.data,f=ye(t,a,r);f!==null&&(Tt(t,i,f,c,r),a.data=c,n.dataAttributeNames.push(i))}}function mc(t,e,r){let n=e.classes?.[r.class];if(!n)throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${r.class}`);let o=r.count;for(let s in n.properties){let i=n.properties[s],a=r.properties?.[s];if(a){let c=pc(t,e,i,o,a);a.data=c}}}function pc(t,e,r,n,o){let s=[],i=o.values,a=t.getTypedArrayForBufferView(i),c=hc(t,r,o,n),f=uc(t,o,n);switch(r.type){case"SCALAR":case"VEC2":case"VEC3":case"VEC4":case"MAT2":case"MAT3":case"MAT4":{s=dc(r,n,a,c);break}case"BOOLEAN":throw new Error(`Not implemented - classProperty.type=${r.type}`);case"STRING":{s=It(n,a,c,f);break}case"ENUM":{s=gc(e,r,n,a,c);break}default:throw new Error(`Unknown classProperty type ${r.type}`)}return s}function hc(t,e,r,n){return e.array&&typeof e.count>"u"&&typeof r.arrayOffsets<"u"?_e(t,r.arrayOffsets,r.arrayOffsetType||"UINT32",n):null}function uc(t,e,r){return typeof e.stringOffsets<"u"?_e(t,e.stringOffsets,e.stringOffsetType||"UINT32",r):null}function dc(t,e,r,n){let o=t.array,s=t.count,i=Qe(t.type,t.componentType),a=r.byteLength/i,c;return t.componentType?c=Te(r,t.type,t.componentType,a):c=r,o?n?yt(c,e,n,r.length,i):s?Rt(c,e,s):[]:c}function gc(t,e,r,n,o){let s=e.enumType;if(!s)throw new Error("Incorrect data in the EXT_structural_metadata extension: classProperty.enumType is not set for type ENUM");let i=t.enums?.[s];if(!i)throw new Error(`Incorrect data in the EXT_structural_metadata extension: schema.enums does't contain ${s}`);let a=i.valueType||"UINT16",c=Qe(e.type,a),f=n.byteLength/c,l=Te(n,e.type,a,f);if(l||(l=n),e.array){if(o)return Bc({valuesData:l,numberOfElements:r,arrayOffsets:o,valuesDataBytesLength:n.length,elementSize:c,enumEntry:i});let A=e.count;return A?Cc(l,r,A,i):[]}return br(l,0,r,i)}function Bc(t){let{valuesData:e,numberOfElements:r,arrayOffsets:n,valuesDataBytesLength:o,elementSize:s,enumEntry:i}=t,a=[];for(let c=0;c<r;c++){let f=n[c],l=n[c+1]-n[c];if(l+f>o)break;let A=f/s,m=l/s,p=br(e,A,m,i);a.push(p)}return a}function Cc(t,e,r,n){let o=[];for(let s=0;s<e;s++){let i=r*s,a=br(t,i,r,n);o.push(a)}return o}function br(t,e,r,n){let o=[];for(let s=0;s<r;s++)if(t instanceof BigInt64Array||t instanceof BigUint64Array)o.push("");else{let i=t[e+s],a=xc(n,i);a?o.push(a.name):o.push("")}return o}function xc(t,e){for(let r of t.values)if(r.value===e)return r;return null}var Mc="schemaClassId";function Ec(t,e){let r=t.getExtension(Ie);if(r&&r.propertyTables)for(let n of r.propertyTables){let o=n.class,s=r.schema?.classes?.[o];n.properties&&s&&bc(n,s,t)}}function bc(t,e,r){for(let n in t.properties){let o=t.properties[n].data;if(o){let s=e.properties[n];if(s){let i=Rc(o,s,r);t.properties[n]=i}}}}function _c(t,e,r=Mc){let n=t.getExtension(Ie);n||(n=t.addExtension(Ie)),n.schema=Tc(e,r,n.schema);let o=yc(e,r,n.schema);return n.propertyTables||(n.propertyTables=[]),n.propertyTables.push(o)-1}function Tc(t,e,r){let n=r??{id:"schema_id"},o={properties:{}};for(let s of t){let i={type:s.elementType,componentType:s.componentType};o.properties[s.name]=i}return n.classes={},n.classes[e]=o,n}function yc(t,e,r){let n={class:e,count:0},o=0,s=r.classes?.[e];for(let i of t){if(o===0&&(o=i.values.length),o!==i.values.length&&i.values.length)throw new Error("Illegal values in attributes");s?.properties[i.name]&&(n.properties||(n.properties={}),n.properties[i.name]={values:0,data:i.values})}return n.count=o,n}function Rc(t,e,r){let n={values:0};if(e.type==="STRING"){let{stringData:o,stringOffsets:s}=Fc(t);n.stringOffsets=Er(s,r),n.values=Er(o,r)}else if(e.type==="SCALAR"&&e.componentType){let o=Sc(t,e.componentType);n.values=Er(o,r)}return n}var Ic={INT8:Int8Array,UINT8:Uint8Array,INT16:Int16Array,UINT16:Uint16Array,INT32:Int32Array,UINT32:Uint32Array,INT64:Int32Array,UINT64:Uint32Array,FLOAT32:Float32Array,FLOAT64:Float64Array};function Sc(t,e){let r=[];for(let o of t)r.push(Number(o));let n=Ic[e];if(!n)throw new Error("Illegal component type");return new n(r)}function Fc(t){let e=new TextEncoder,r=[],n=0;for(let c of t){let f=e.encode(c);n+=f.length,r.push(f)}let o=new Uint8Array(n),s=[],i=0;for(let c of r)o.set(c,i),s.push(i),i+=c.length;s.push(i);let a=new Uint32Array(s);return{stringData:o,stringOffsets:a}}function Er(t,e){return e.gltf.buffers.push({arrayBuffer:t.buffer,byteOffset:t.byteOffset,byteLength:t.byteLength}),e.addBufferView(t)}var Tr={};P(Tr,{decode:()=>vc,name:()=>Lc});var gs="EXT_feature_metadata",Lc=gs;async function vc(t,e){let r=new _(t);Gc(r,e)}function Gc(t,e){if(!e.gltf?.loadBuffers)return;let r=t.getExtension(gs);r&&(e.gltf?.loadImages&&Oc(t,r),Dc(t,r))}function Oc(t,e){let r=e.schema;if(!r)return;let n=r.classes,{featureTextures:o}=e;if(n&&o)for(let s in n){let i=n[s],a=wc(o,s);a&&Hc(t,a,i)}}function Dc(t,e){let r=e.schema;if(!r)return;let n=r.classes,o=e.featureTables;if(n&&o)for(let s in n){let i=Pc(o,s);i&&Nc(t,r,i)}}function Pc(t,e){for(let r in t){let n=t[r];if(n.class===e)return n}return null}function wc(t,e){for(let r in t){let n=t[r];if(n.class===e)return n}return null}function Nc(t,e,r){if(!r.class)return;let n=e.classes?.[r.class];if(!n)throw new Error(`Incorrect data in the EXT_structural_metadata extension: no schema class with name ${r.class}`);let o=r.count;for(let s in n.properties){let i=n.properties[s],a=r.properties?.[s];if(a){let c=Uc(t,e,i,o,a);a.data=c}}}function Hc(t,e,r){let n=e.class;for(let o in r.properties){let s=e?.properties?.[o];if(s){let i=jc(t,s,n);s.data=i}}}function Uc(t,e,r,n,o){let s=[],i=o.bufferView,a=t.getTypedArrayForBufferView(i),c=Jc(t,r,o,n),f=Kc(t,r,o,n);return r.type==="STRING"||r.componentType==="STRING"?s=It(n,a,c,f):Vc(r)&&(s=Xc(r,n,a,c)),s}function Jc(t,e,r,n){return e.type==="ARRAY"&&typeof e.componentCount>"u"&&typeof r.arrayOffsetBufferView<"u"?_e(t,r.arrayOffsetBufferView,r.offsetType||"UINT32",n):null}function Kc(t,e,r,n){return typeof r.stringOffsetBufferView<"u"?_e(t,r.stringOffsetBufferView,r.offsetType||"UINT32",n):null}function Vc(t){let e=["UINT8","INT16","UINT16","INT32","UINT32","INT64","UINT64","FLOAT32","FLOAT64"];return e.includes(t.type)||typeof t.componentType<"u"&&e.includes(t.componentType)}function Xc(t,e,r,n){let o=t.type==="ARRAY",s=t.componentCount,i="SCALAR",a=t.componentType||t.type,c=Qe(i,a),f=r.byteLength/c,l=Te(r,i,a,f);return o?n?yt(l,e,n,r.length,c):s?Rt(l,e,s):[]:l}function jc(t,e,r){let n=t.gltf.json;if(!n.meshes)return[];let o=[];for(let s of n.meshes)for(let i of s.primitives)kc(t,r,e,o,i);return o}function kc(t,e,r,n,o){let s={channels:r.channels,...r.texture},i=ye(t,s,o);i&&Tt(t,e,i,n,o)}var Bs="4.3.3";var Cs="4.3.3";var St={TRANSCODER:"basis_transcoder.js",TRANSCODER_WASM:"basis_transcoder.wasm",ENCODER:"basis_encoder.js",ENCODER_WASM:"basis_encoder.wasm"},xs;async function Rr(t){fr(t.modules);let e=lr("basis");return e||(xs||=Qc(t),await xs)}async function Qc(t){let e=null,r=null;return[e,r]=await Promise.all([await j(St.TRANSCODER,"textures",t),await j(St.TRANSCODER_WASM,"textures",t)]),e=e||globalThis.BASIS,await zc(e,r)}function zc(t,e){let r={};return e&&(r.wasmBinary=e),new Promise(n=>{t(r).then(o=>{let{BasisFile:s,initializeBasis:i}=o;i(),n({BasisFile:s})})})}var yr;async function Ir(t){let e=t.modules||{};return e.basisEncoder?e.basisEncoder:(yr=yr||Yc(t),await yr)}async function Yc(t){let e=null,r=null;return[e,r]=await Promise.all([await j(St.ENCODER,"textures",t),await j(St.ENCODER_WASM,"textures",t)]),e=e||globalThis.BASIS,await Wc(e,r)}function Wc(t,e){let r={};return e&&(r.wasmBinary=e),new Promise(n=>{t(r).then(o=>{let{BasisFile:s,KTX2File:i,initializeBasis:a,BasisEncoder:c}=o;a(),n({BasisFile:s,KTX2File:i,BasisEncoder:c})})})}var le={COMPRESSED_RGB_S3TC_DXT1_EXT:33776,COMPRESSED_RGBA_S3TC_DXT1_EXT:33777,COMPRESSED_RGBA_S3TC_DXT3_EXT:33778,COMPRESSED_RGBA_S3TC_DXT5_EXT:33779,COMPRESSED_R11_EAC:37488,COMPRESSED_SIGNED_R11_EAC:37489,COMPRESSED_RG11_EAC:37490,COMPRESSED_SIGNED_RG11_EAC:37491,COMPRESSED_RGB8_ETC2:37492,COMPRESSED_RGBA8_ETC2_EAC:37493,COMPRESSED_SRGB8_ETC2:37494,COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:37495,COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:37496,COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:37497,COMPRESSED_RGB_PVRTC_4BPPV1_IMG:35840,COMPRESSED_RGBA_PVRTC_4BPPV1_IMG:35842,COMPRESSED_RGB_PVRTC_2BPPV1_IMG:35841,COMPRESSED_RGBA_PVRTC_2BPPV1_IMG:35843,COMPRESSED_RGB_ETC1_WEBGL:36196,COMPRESSED_RGB_ATC_WEBGL:35986,COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL:35987,COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL:34798,COMPRESSED_RGBA_ASTC_4X4_KHR:37808,COMPRESSED_RGBA_ASTC_5X4_KHR:37809,COMPRESSED_RGBA_ASTC_5X5_KHR:37810,COMPRESSED_RGBA_ASTC_6X5_KHR:37811,COMPRESSED_RGBA_ASTC_6X6_KHR:37812,COMPRESSED_RGBA_ASTC_8X5_KHR:37813,COMPRESSED_RGBA_ASTC_8X6_KHR:37814,COMPRESSED_RGBA_ASTC_8X8_KHR:37815,COMPRESSED_RGBA_ASTC_10X5_KHR:37816,COMPRESSED_RGBA_ASTC_10X6_KHR:37817,COMPRESSED_RGBA_ASTC_10X8_KHR:37818,COMPRESSED_RGBA_ASTC_10X10_KHR:37819,COMPRESSED_RGBA_ASTC_12X10_KHR:37820,COMPRESSED_RGBA_ASTC_12X12_KHR:37821,COMPRESSED_SRGB8_ALPHA8_ASTC_4X4_KHR:37840,COMPRESSED_SRGB8_ALPHA8_ASTC_5X4_KHR:37841,COMPRESSED_SRGB8_ALPHA8_ASTC_5X5_KHR:37842,COMPRESSED_SRGB8_ALPHA8_ASTC_6X5_KHR:37843,COMPRESSED_SRGB8_ALPHA8_ASTC_6X6_KHR:37844,COMPRESSED_SRGB8_ALPHA8_ASTC_8X5_KHR:37845,COMPRESSED_SRGB8_ALPHA8_ASTC_8X6_KHR:37846,COMPRESSED_SRGB8_ALPHA8_ASTC_8X8_KHR:37847,COMPRESSED_SRGB8_ALPHA8_ASTC_10X5_KHR:37848,COMPRESSED_SRGB8_ALPHA8_ASTC_10X6_KHR:37849,COMPRESSED_SRGB8_ALPHA8_ASTC_10X8_KHR:37850,COMPRESSED_SRGB8_ALPHA8_ASTC_10X10_KHR:37851,COMPRESSED_SRGB8_ALPHA8_ASTC_12X10_KHR:37852,COMPRESSED_SRGB8_ALPHA8_ASTC_12X12_KHR:37853,COMPRESSED_RED_RGTC1_EXT:36283,COMPRESSED_SIGNED_RED_RGTC1_EXT:36284,COMPRESSED_RED_GREEN_RGTC2_EXT:36285,COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT:36286,COMPRESSED_SRGB_S3TC_DXT1_EXT:35916,COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:35917,COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:35918,COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:35919};var qc=["","WEBKIT_","MOZ_"],Ms={WEBGL_compressed_texture_s3tc:"dxt",WEBGL_compressed_texture_s3tc_srgb:"dxt-srgb",WEBGL_compressed_texture_etc1:"etc1",WEBGL_compressed_texture_etc:"etc2",WEBGL_compressed_texture_pvrtc:"pvrtc",WEBGL_compressed_texture_atc:"atc",WEBGL_compressed_texture_astc:"astc",EXT_texture_compression_rgtc:"rgtc"},Ft=null;function Es(t){if(!Ft){t=t||Zc()||void 0,Ft=new Set;for(let e of qc)for(let r in Ms)if(t&&t.getExtension(`${e}${r}`)){let n=Ms[r];Ft.add(n)}}return Ft}function Zc(){try{return document.createElement("canvas").getContext("webgl")}catch{return null}}var D=[171,75,84,88,32,50,48,187,13,10,26,10];function bs(t){let e=new Uint8Array(t);return!(e.byteLength<D.length||e[0]!==D[0]||e[1]!==D[1]||e[2]!==D[2]||e[3]!==D[3]||e[4]!==D[4]||e[5]!==D[5]||e[6]!==D[6]||e[7]!==D[7]||e[8]!==D[8]||e[9]!==D[9]||e[10]!==D[10]||e[11]!==D[11])}var $c={etc1:{basisFormat:0,compressed:!0,format:le.COMPRESSED_RGB_ETC1_WEBGL},etc2:{basisFormat:1,compressed:!0},bc1:{basisFormat:2,compressed:!0,format:le.COMPRESSED_RGB_S3TC_DXT1_EXT},bc3:{basisFormat:3,compressed:!0,format:le.COMPRESSED_RGBA_S3TC_DXT5_EXT},bc4:{basisFormat:4,compressed:!0},bc5:{basisFormat:5,compressed:!0},"bc7-m6-opaque-only":{basisFormat:6,compressed:!0},"bc7-m5":{basisFormat:7,compressed:!0},"pvrtc1-4-rgb":{basisFormat:8,compressed:!0,format:le.COMPRESSED_RGB_PVRTC_4BPPV1_IMG},"pvrtc1-4-rgba":{basisFormat:9,compressed:!0,format:le.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG},"astc-4x4":{basisFormat:10,compressed:!0,format:le.COMPRESSED_RGBA_ASTC_4X4_KHR},"atc-rgb":{basisFormat:11,compressed:!0},"atc-rgba-interpolated-alpha":{basisFormat:12,compressed:!0},rgba32:{basisFormat:13,compressed:!1},rgb565:{basisFormat:14,compressed:!1},bgr565:{basisFormat:15,compressed:!1},rgba4444:{basisFormat:16,compressed:!1}};async function Ts(t,e){if(e.basis.containerFormat==="auto"){if(bs(t)){let n=await Ir(e);return _s(n.KTX2File,t,e)}let{BasisFile:r}=await Rr(e);return Sr(r,t,e)}switch(e.basis.module){case"encoder":let r=await Ir(e);switch(e.basis.containerFormat){case"ktx2":return _s(r.KTX2File,t,e);case"basis":default:return Sr(r.BasisFile,t,e)}case"transcoder":default:let{BasisFile:n}=await Rr(e);return Sr(n,t,e)}}function Sr(t,e,r){let n=new t(new Uint8Array(e));try{if(!n.startTranscoding())throw new Error("Failed to start basis transcoding");let o=n.getNumImages(),s=[];for(let i=0;i<o;i++){let a=n.getNumLevels(i),c=[];for(let f=0;f<a;f++)c.push(ef(n,i,f,r));s.push(c)}return s}finally{n.close(),n.delete()}}function ef(t,e,r,n){let o=t.getImageWidth(e,r),s=t.getImageHeight(e,r),i=t.getHasAlpha(),{compressed:a,format:c,basisFormat:f}=ys(n,i),l=t.getImageTranscodedSizeInBytes(e,r,f),A=new Uint8Array(l);if(!t.transcodeImage(A,e,r,f,0,0))throw new Error("failed to start Basis transcoding");return{width:o,height:s,data:A,compressed:a,format:c,hasAlpha:i}}function _s(t,e,r){let n=new t(new Uint8Array(e));try{if(!n.startTranscoding())throw new Error("failed to start KTX2 transcoding");let o=n.getLevels(),s=[];for(let i=0;i<o;i++)s.push(tf(n,i,r));return[s]}finally{n.close(),n.delete()}}function tf(t,e,r){let{alphaFlag:n,height:o,width:s}=t.getImageLevelInfo(e,0,0),{compressed:i,format:a,basisFormat:c}=ys(r,n),f=t.getImageTranscodedSizeInBytes(e,0,0,c),l=new Uint8Array(f);if(!t.transcodeImage(l,e,0,0,c,0,-1,-1))throw new Error("Failed to transcode KTX2 image");return{width:s,height:o,data:l,compressed:i,levelSize:f,hasAlpha:n,format:a}}function ys(t,e){let r=t&&t.basis&&t.basis.format;return r==="auto"&&(r=Lt()),typeof r=="object"&&(r=e?r.alpha:r.noAlpha),r=r.toLowerCase(),$c[r]}function Lt(){let t=Es();return t.has("astc")?"astc-4x4":t.has("dxt")?{alpha:"bc3",noAlpha:"bc1"}:t.has("pvrtc")?{alpha:"pvrtc1-4-rgba",noAlpha:"pvrtc1-4-rgb"}:t.has("etc1")?"etc1":t.has("etc2")?"etc2":"rgb565"}var Rs={dataType:null,batchType:null,name:"Basis",id:"basis",module:"textures",version:Cs,worker:!0,extensions:["basis","ktx2"],mimeTypes:["application/octet-stream","image/ktx2"],tests:["sB"],binary:!0,options:{basis:{format:"auto",libraryPath:"libs/",containerFormat:"auto",module:"transcoder"}}},Fr={...Rs,parse:Ts};var Se=!0,Is=1735152710,Gr=12,vt=8,rf=1313821514,nf=5130562,of=0,sf=0,af=1;function cf(t,e=0){return`${String.fromCharCode(t.getUint8(e+0))}${String.fromCharCode(t.getUint8(e+1))}${String.fromCharCode(t.getUint8(e+2))}${String.fromCharCode(t.getUint8(e+3))}`}function Ss(t,e=0,r={}){let n=new DataView(t),{magic:o=Is}=r,s=n.getUint32(e,!1);return s===o||s===Is}function Fs(t,e,r=0,n={}){let o=new DataView(e),s=cf(o,r+0),i=o.getUint32(r+4,Se),a=o.getUint32(r+8,Se);switch(Object.assign(t,{header:{byteOffset:r,byteLength:a,hasBinChunk:!1},type:s,version:i,json:{},binChunks:[]}),r+=Gr,t.version){case 1:return ff(t,o,r);case 2:return lf(t,o,r,n={});default:throw new Error(`Invalid GLB version ${t.version}. Only supports version 1 and 2.`)}}function ff(t,e,r){w(t.header.byteLength>Gr+vt);let n=e.getUint32(r+0,Se),o=e.getUint32(r+4,Se);return r+=vt,w(o===of),Lr(t,e,r,n),r+=n,r+=vr(t,e,r,t.header.byteLength),r}function lf(t,e,r,n){return w(t.header.byteLength>Gr+vt),Af(t,e,r,n),r+t.header.byteLength}function Af(t,e,r,n){for(;r+8<=t.header.byteLength;){let o=e.getUint32(r+0,Se),s=e.getUint32(r+4,Se);switch(r+=vt,s){case rf:Lr(t,e,r,o);break;case nf:vr(t,e,r,o);break;case sf:n.strict||Lr(t,e,r,o);break;case af:n.strict||vr(t,e,r,o);break;default:break}r+=re(o,4)}return r}function Lr(t,e,r,n){let o=new Uint8Array(e.buffer,r,n),i=new TextDecoder("utf8").decode(o);return t.json=JSON.parse(i),re(n,4)}function vr(t,e,r,n){return t.header.hasBinChunk=!0,t.binChunks.push({byteOffset:r,byteLength:n,arrayBuffer:e.buffer}),re(n,4)}function Or(t,e){if(t.startsWith("data:")||t.startsWith("http:")||t.startsWith("https:"))return t;let n=e.baseUri||e.uri;if(!n)throw new Error(`'baseUri' must be provided to resolve relative url ${t}`);return n.substr(0,n.lastIndexOf("/")+1)+t}var Pr={};P(Pr,{decode:()=>bf,name:()=>Ef});var mf="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",pf="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",hf=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]),uf=new Uint8Array([32,0,65,253,3,1,2,34,4,106,6,5,11,8,7,20,13,33,12,16,128,9,116,64,19,113,127,15,10,21,22,14,255,66,24,54,136,107,18,23,192,26,114,118,132,17,77,101,130,144,27,87,131,44,45,74,156,154,70,167]),df={0:"",1:"meshopt_decodeFilterOct",2:"meshopt_decodeFilterQuat",3:"meshopt_decodeFilterExp",NONE:"",OCTAHEDRAL:"meshopt_decodeFilterOct",QUATERNION:"meshopt_decodeFilterQuat",EXPONENTIAL:"meshopt_decodeFilterExp"},gf={0:"meshopt_decodeVertexBuffer",1:"meshopt_decodeIndexBuffer",2:"meshopt_decodeIndexSequence",ATTRIBUTES:"meshopt_decodeVertexBuffer",TRIANGLES:"meshopt_decodeIndexBuffer",INDICES:"meshopt_decodeIndexSequence"};async function Ls(t,e,r,n,o,s="NONE"){let i=await Bf();Mf(i,i.exports[gf[o]],t,e,r,n,i.exports[df[s||"NONE"]])}var Dr;async function Bf(){return Dr||(Dr=Cf()),Dr}async function Cf(){let t=mf;WebAssembly.validate(hf)&&(t=pf,console.log("Warning: meshopt_decoder is using experimental SIMD support"));let e=await WebAssembly.instantiate(xf(t),{});return await e.instance.exports.__wasm_call_ctors(),e.instance}function xf(t){let e=new Uint8Array(t.length);for(let n=0;n<t.length;++n){let o=t.charCodeAt(n);e[n]=o>96?o-71:o>64?o-65:o>47?o+4:o>46?63:62}let r=0;for(let n=0;n<t.length;++n)e[r++]=e[n]<60?uf[e[n]]:(e[n]-60)*64+e[++n];return e.buffer.slice(0,r)}function Mf(t,e,r,n,o,s,i){let a=t.exports.sbrk,c=n+3&-4,f=a(c*o),l=a(s.length),A=new Uint8Array(t.exports.memory.buffer);A.set(s,l);let m=e(f,n,o,l,s.length);if(m===0&&i&&i(f,c,o),r.set(A.subarray(f,f+n*o)),a(f-a(0)),m!==0)throw new Error(`Malformed buffer data: ${m}`)}var Gt="EXT_meshopt_compression",Ef=Gt;async function bf(t,e){let r=new _(t);if(!e?.gltf?.decompressMeshes||!e.gltf?.loadBuffers)return;let n=[];for(let o of t.json.bufferViews||[])n.push(_f(r,o));await Promise.all(n),r.removeExtension(Gt)}async function _f(t,e){let r=t.getObjectExtension(e,Gt);if(r){let{byteOffset:n=0,byteLength:o=0,byteStride:s,count:i,mode:a,filter:c="NONE",buffer:f}=r,l=t.gltf.buffers[f],A=new Uint8Array(l.arrayBuffer,l.byteOffset+n,o),m=new Uint8Array(t.gltf.buffers[e.buffer].arrayBuffer,e.byteOffset,e.byteLength);await Ls(m,i,s,A,a,c),t.removeObjectExtension(e,Gt)}}var wr={};P(wr,{name:()=>Tf,preprocess:()=>yf});var Fe="EXT_texture_webp",Tf=Fe;function yf(t,e){let r=new _(t);if(!xr("image/webp")){if(r.getRequiredExtensions().includes(Fe))throw new Error(`gltf: Required extension ${Fe} not supported by browser`);return}let{json:n}=r;for(let o of n.textures||[]){let s=r.getObjectExtension(o,Fe);s&&(o.source=s.source),r.removeObjectExtension(o,Fe)}r.removeExtension(Fe)}var Nr={};P(Nr,{name:()=>Rf,preprocess:()=>If});var Ot="KHR_texture_basisu",Rf=Ot;function If(t,e){let r=new _(t),{json:n}=r;for(let o of n.textures||[]){let s=r.getObjectExtension(o,Ot);s&&(o.source=s.source,r.removeObjectExtension(o,Ot))}r.removeExtension(Ot)}var Vr={};P(Vr,{decode:()=>Xf,encode:()=>jf,name:()=>Kf,preprocess:()=>Vf});var vs="4.3.3";var Gs={dataType:null,batchType:null,name:"Draco",id:"draco",module:"draco",version:vs,worker:!0,extensions:["drc"],mimeTypes:["application/octet-stream"],binary:!0,tests:["DRACO"],options:{draco:{decoderType:typeof WebAssembly=="object"?"wasm":"js",libraryPath:"libs/",extraAttributes:{},attributeNameEntry:void 0}}};function Ds(t,e,r){let n=Ps(e.metadata),o=[],s=Sf(e.attributes);for(let i in t){let a=t[i],c=Os(i,a,s[i]);o.push(c)}if(r){let i=Os("indices",r);o.push(i)}return{fields:o,metadata:n}}function Sf(t){let e={};for(let r in t){let n=t[r];e[n.name||"undefined"]=n}return e}function Os(t,e,r){let n=r?Ps(r.metadata):void 0;return nr(t,e,n)}function Ps(t){Object.entries(t);let e={};for(let r in t)e[`${r}.string`]=JSON.stringify(t[r]);return e}var ws={POSITION:"POSITION",NORMAL:"NORMAL",COLOR:"COLOR_0",TEX_COORD:"TEXCOORD_0"},Ff={1:Int8Array,2:Uint8Array,3:Int16Array,4:Uint16Array,5:Int32Array,6:Uint32Array,9:Float32Array},Lf=4,ze=class{draco;decoder;metadataQuerier;constructor(e){this.draco=e,this.decoder=new this.draco.Decoder,this.metadataQuerier=new this.draco.MetadataQuerier}destroy(){this.draco.destroy(this.decoder),this.draco.destroy(this.metadataQuerier)}parseSync(e,r={}){let n=new this.draco.DecoderBuffer;n.Init(new Int8Array(e),e.byteLength),this._disableAttributeTransforms(r);let o=this.decoder.GetEncodedGeometryType(n),s=o===this.draco.TRIANGULAR_MESH?new this.draco.Mesh:new this.draco.PointCloud;try{let i;switch(o){case this.draco.TRIANGULAR_MESH:i=this.decoder.DecodeBufferToMesh(n,s);break;case this.draco.POINT_CLOUD:i=this.decoder.DecodeBufferToPointCloud(n,s);break;default:throw new Error("DRACO: Unknown geometry type.")}if(!i.ok()||!s.ptr){let m=`DRACO decompression failed: ${i.error_msg()}`;throw new Error(m)}let a=this._getDracoLoaderData(s,o,r),c=this._getMeshData(s,a,r),f=Ne(c.attributes),l=Ds(c.attributes,a,c.indices);return{loader:"draco",loaderData:a,header:{vertexCount:s.num_points(),boundingBox:f},...c,schema:l}}finally{this.draco.destroy(n),s&&this.draco.destroy(s)}}_getDracoLoaderData(e,r,n){let o=this._getTopLevelMetadata(e),s=this._getDracoAttributes(e,n);return{geometry_type:r,num_attributes:e.num_attributes(),num_points:e.num_points(),num_faces:e instanceof this.draco.Mesh?e.num_faces():0,metadata:o,attributes:s}}_getDracoAttributes(e,r){let n={};for(let o=0;o<e.num_attributes();o++){let s=this.decoder.GetAttribute(e,o),i=this._getAttributeMetadata(e,o);n[s.unique_id()]={unique_id:s.unique_id(),attribute_type:s.attribute_type(),data_type:s.data_type(),num_components:s.num_components(),byte_offset:s.byte_offset(),byte_stride:s.byte_stride(),normalized:s.normalized(),attribute_index:o,metadata:i};let a=this._getQuantizationTransform(s,r);a&&(n[s.unique_id()].quantization_transform=a);let c=this._getOctahedronTransform(s,r);c&&(n[s.unique_id()].octahedron_transform=c)}return n}_getMeshData(e,r,n){let o=this._getMeshAttributes(r,e,n);if(!o.POSITION)throw new Error("DRACO: No position attribute found.");if(e instanceof this.draco.Mesh)switch(n.topology){case"triangle-strip":return{topology:"triangle-strip",mode:4,attributes:o,indices:{value:this._getTriangleStripIndices(e),size:1}};case"triangle-list":default:return{topology:"triangle-list",mode:5,attributes:o,indices:{value:this._getTriangleListIndices(e),size:1}}}return{topology:"point-list",mode:0,attributes:o}}_getMeshAttributes(e,r,n){let o={};for(let s of Object.values(e.attributes)){let i=this._deduceAttributeName(s,n);s.name=i;let a=this._getAttributeValues(r,s);if(a){let{value:c,size:f}=a;o[i]={value:c,size:f,byteOffset:s.byte_offset,byteStride:s.byte_stride,normalized:s.normalized}}}return o}_getTriangleListIndices(e){let n=e.num_faces()*3,o=n*Lf,s=this.draco._malloc(o);try{return this.decoder.GetTrianglesUInt32Array(e,o,s),new Uint32Array(this.draco.HEAPF32.buffer,s,n).slice()}finally{this.draco._free(s)}}_getTriangleStripIndices(e){let r=new this.draco.DracoInt32Array;try{return this.decoder.GetTriangleStripsFromMesh(e,r),Of(r)}finally{this.draco.destroy(r)}}_getAttributeValues(e,r){let n=Ff[r.data_type];if(!n)return console.warn(`DRACO: Unsupported attribute type ${r.data_type}`),null;let o=r.num_components,i=e.num_points()*o,a=i*n.BYTES_PER_ELEMENT,c=vf(this.draco,n),f,l=this.draco._malloc(a);try{let A=this.decoder.GetAttribute(e,r.attribute_index);this.decoder.GetAttributeDataArrayForAllPoints(e,A,c,a,l),f=new n(this.draco.HEAPF32.buffer,l,i).slice()}finally{this.draco._free(l)}return{value:f,size:o}}_deduceAttributeName(e,r){let n=e.unique_id;for(let[i,a]of Object.entries(r.extraAttributes||{}))if(a===n)return i;let o=e.attribute_type;for(let i in ws)if(this.draco[i]===o)return ws[i];let s=r.attributeNameEntry||"name";return e.metadata[s]?e.metadata[s].string:`CUSTOM_ATTRIBUTE_${n}`}_getTopLevelMetadata(e){let r=this.decoder.GetMetadata(e);return this._getDracoMetadata(r)}_getAttributeMetadata(e,r){let n=this.decoder.GetAttributeMetadata(e,r);return this._getDracoMetadata(n)}_getDracoMetadata(e){if(!e||!e.ptr)return{};let r={},n=this.metadataQuerier.NumEntries(e);for(let o=0;o<n;o++){let s=this.metadataQuerier.GetEntryName(e,o);r[s]=this._getDracoMetadataField(e,s)}return r}_getDracoMetadataField(e,r){let n=new this.draco.DracoInt32Array;try{this.metadataQuerier.GetIntEntryArray(e,r,n);let o=Gf(n);return{int:this.metadataQuerier.GetIntEntry(e,r),string:this.metadataQuerier.GetStringEntry(e,r),double:this.metadataQuerier.GetDoubleEntry(e,r),intArray:o}}finally{this.draco.destroy(n)}}_disableAttributeTransforms(e){let{quantizedAttributes:r=[],octahedronAttributes:n=[]}=e,o=[...r,...n];for(let s of o)this.decoder.SkipAttributeTransform(this.draco[s])}_getQuantizationTransform(e,r){let{quantizedAttributes:n=[]}=r,o=e.attribute_type();if(n.map(i=>this.decoder[i]).includes(o)){let i=new this.draco.AttributeQuantizationTransform;try{if(i.InitFromAttribute(e))return{quantization_bits:i.quantization_bits(),range:i.range(),min_values:new Float32Array([1,2,3]).map(a=>i.min_value(a))}}finally{this.draco.destroy(i)}}return null}_getOctahedronTransform(e,r){let{octahedronAttributes:n=[]}=r,o=e.attribute_type();if(n.map(i=>this.decoder[i]).includes(o)){let i=new this.draco.AttributeQuantizationTransform;try{if(i.InitFromAttribute(e))return{quantization_bits:i.quantization_bits()}}finally{this.draco.destroy(i)}}return null}};function vf(t,e){switch(e){case Float32Array:return t.DT_FLOAT32;case Int8Array:return t.DT_INT8;case Int16Array:return t.DT_INT16;case Int32Array:return t.DT_INT32;case Uint8Array:return t.DT_UINT8;case Uint16Array:return t.DT_UINT16;case Uint32Array:return t.DT_UINT32;default:return t.DT_INVALID}}function Gf(t){let e=t.size(),r=new Int32Array(e);for(let n=0;n<e;n++)r[n]=t.GetValue(n);return r}function Of(t){let e=t.size(),r=new Int32Array(e);for(let n=0;n<e;n++)r[n]=t.GetValue(n);return r}var Df="1.5.6",Pf="1.4.1",Hr=`https://www.gstatic.com/draco/versioned/decoders/${Df}`,F={DECODER:"draco_wasm_wrapper.js",DECODER_WASM:"draco_decoder.wasm",FALLBACK_DECODER:"draco_decoder.js",ENCODER:"draco_encoder.js"},Ur={[F.DECODER]:`${Hr}/${F.DECODER}`,[F.DECODER_WASM]:`${Hr}/${F.DECODER_WASM}`,[F.FALLBACK_DECODER]:`${Hr}/${F.FALLBACK_DECODER}`,[F.ENCODER]:`https://raw.githubusercontent.com/google/draco/${Pf}/javascript/${F.ENCODER}`},Jr;async function Ns(t){let e=t.modules||{};return e.draco3d?Jr||=e.draco3d.createDecoderModule({}).then(r=>({draco:r})):Jr||=wf(t),await Jr}async function wf(t){let e,r;switch(t.draco&&t.draco.decoderType){case"js":e=await j(Ur[F.FALLBACK_DECODER],"draco",t,F.FALLBACK_DECODER);break;case"wasm":default:[e,r]=await Promise.all([await j(Ur[F.DECODER],"draco",t,F.DECODER),await j(Ur[F.DECODER_WASM],"draco",t,F.DECODER_WASM)])}return e=e||globalThis.DracoDecoderModule,await Nf(e,r)}function Nf(t,e){let r={};return e&&(r.wasmBinary=e),new Promise(n=>{t({...r,onModuleLoaded:o=>n({draco:o})})})}var Hs={...Gs,parse:Hf};async function Hf(t,e){let{draco:r}=await Ns(e),n=new ze(r);try{return n.parseSync(t,e?.draco)}finally{n.destroy()}}function Us(t){let e={};for(let r in t){let n=t[r];if(r!=="indices"){let o=Kr(n);e[r]=o}}return e}function Kr(t){let{buffer:e,size:r,count:n}=Uf(t);return{value:e,size:r,byteOffset:0,count:n,type:_t(r),componentType:ne(e)}}function Uf(t){let e=t,r=1,n=0;return t&&t.value&&(e=t.value,r=t.size||1),e&&(ArrayBuffer.isView(e)||(e=Jf(e,Float32Array)),n=e.length/r),{buffer:e,size:r,count:n}}function Jf(t,e,r=!1){return t?Array.isArray(t)?new e(t):r&&!(t instanceof e)?new e(t):t:null}var oe="KHR_draco_mesh_compression",Kf=oe;function Vf(t,e,r){let n=new _(t);for(let o of Js(n))n.getObjectExtension(o,oe)}async function Xf(t,e,r){if(!e?.gltf?.decompressMeshes)return;let n=new _(t),o=[];for(let s of Js(n))n.getObjectExtension(s,oe)&&o.push(kf(n,s,e,r));await Promise.all(o),n.removeExtension(oe)}function jf(t,e={}){let r=new _(t);for(let n of r.json.meshes||[])Qf(n,e),r.addRequiredExtension(oe)}async function kf(t,e,r,n){let o=t.getObjectExtension(e,oe);if(!o)return;let s=t.getTypedArrayForBufferView(o.bufferView),i=Ve(s.buffer,s.byteOffset),a={...r};delete a["3d-tiles"];let c=await Je(i,Hs,a,n),f=Us(c.attributes);for(let[l,A]of Object.entries(f))if(l in e.attributes){let m=e.attributes[l],p=t.getAccessor(m);p?.min&&p?.max&&(A.min=p.min,A.max=p.max)}e.attributes=f,c.indices&&(e.indices=Kr(c.indices)),t.removeObjectExtension(e,oe),zf(e)}function Qf(t,e,r=4,n,o){if(!n.DracoWriter)throw new Error("options.gltf.DracoWriter not provided");let s=n.DracoWriter.encodeSync({attributes:t}),i=o?.parseSync?.({attributes:t}),a=n._addFauxAttributes(i.attributes),c=n.addBufferView(s);return{primitives:[{attributes:a,mode:r,extensions:{[oe]:{bufferView:c,attributes:a}}}]}}function zf(t){if(!t.attributes&&Object.keys(t.attributes).length>0)throw new Error("glTF: Empty primitive detected: Draco decompression failure?")}function*Js(t){for(let e of t.json.meshes||[])for(let r of e.primitives)yield r}var Xr={};P(Xr,{decode:()=>Zf,name:()=>Yf});var Pt="KHR_texture_transform",Yf=Pt,Dt=new ie,Wf=new Y,qf=new Y;async function Zf(t,e){if(!new _(t).hasExtension(Pt)||!e.gltf?.loadBuffers)return;let o=t.json.materials||[];for(let s=0;s<o.length;s++)$f(s,t)}function $f(t,e){let r=e.json.materials?.[t],n=[r?.pbrMetallicRoughness?.baseColorTexture,r?.emissiveTexture,r?.normalTexture,r?.occlusionTexture,r?.pbrMetallicRoughness?.metallicRoughnessTexture],o=[];for(let s of n)s&&s?.extensions?.[Pt]&&el(e,t,s,o)}function el(t,e,r,n){let o=tl(r,n);if(!o)return;let s=t.json.meshes||[];for(let i of s)for(let a of i.primitives){let c=a.material;Number.isFinite(c)&&e===c&&rl(t,a,o)}}function tl(t,e){let r=t.extensions?.[Pt],{texCoord:n=0}=t,{texCoord:o=n}=r;if(!(e.findIndex(([i,a])=>i===n&&a===o)!==-1)){let i=sl(r);return n!==o&&(t.texCoord=o),e.push([n,o]),{originalTexCoord:n,texCoord:o,matrix:i}}return null}function rl(t,e,r){let{originalTexCoord:n,texCoord:o,matrix:s}=r,i=e.attributes[`TEXCOORD_${n}`];if(Number.isFinite(i)){let a=t.json.accessors?.[i];if(a&&a.bufferView){let c=t.json.bufferViews?.[a.bufferView];if(c){let{arrayBuffer:f,byteOffset:l}=t.buffers[c.buffer],A=(l||0)+(a.byteOffset||0)+(c.byteOffset||0),{ArrayType:m,length:p}=be(a,c),h=bt[a.componentType],u=Et[a.type],g=c.byteStride||h*u,B=new Float32Array(p);for(let E=0;E<a.count;E++){let d=new m(f,A+E*g,2);Dt.set(d[0],d[1],1),Dt.transformByMatrix3(s),B.set([Dt[0],Dt[1]],E*u)}n===o?nl(a,c,t.buffers,B):ol(o,a,e,t,B)}}}}function nl(t,e,r,n){t.componentType=5126,r.push({arrayBuffer:n.buffer,byteOffset:0,byteLength:n.buffer.byteLength}),e.buffer=r.length-1,e.byteLength=n.buffer.byteLength,e.byteOffset=0,delete e.byteStride}function ol(t,e,r,n,o){n.buffers.push({arrayBuffer:o.buffer,byteOffset:0,byteLength:o.buffer.byteLength});let s=n.json.bufferViews;if(!s)return;s.push({buffer:n.buffers.length-1,byteLength:o.buffer.byteLength,byteOffset:0});let i=n.json.accessors;i&&(i.push({bufferView:s?.length-1,byteOffset:0,componentType:5126,count:e.count,type:"VEC2"}),r.attributes[`TEXCOORD_${t}`]=i.length-1)}function sl(t){let{offset:e=[0,0],rotation:r=0,scale:n=[1,1]}=t,o=new Y().set(1,0,0,0,1,0,e[0],e[1],1),s=Wf.set(Math.cos(r),Math.sin(r),0,-Math.sin(r),Math.cos(r),0,0,0,1),i=qf.set(n[0],0,0,0,n[1],0,0,0,1);return o.multiplyRight(s).multiplyRight(i)}var jr={};P(jr,{decode:()=>al,encode:()=>cl,name:()=>il});var Ae="KHR_lights_punctual",il=Ae;async function al(t){let e=new _(t),{json:r}=e,n=e.getExtension(Ae);n&&(e.json.lights=n.lights,e.removeExtension(Ae));for(let o of r.nodes||[]){let s=e.getObjectExtension(o,Ae);s&&(o.light=s.light),e.removeObjectExtension(o,Ae)}}async function cl(t){let e=new _(t),{json:r}=e;if(r.lights){let n=e.addExtension(Ae);R(!n.lights),n.lights=r.lights,delete r.lights}if(e.json.lights){for(let n of e.json.lights){let o=n.node;e.addObjectExtension(o,Ae,n)}delete e.json.lights}}var kr={};P(kr,{decode:()=>ll,encode:()=>Al,name:()=>fl});var Ye="KHR_materials_unlit",fl=Ye;async function ll(t){let e=new _(t),{json:r}=e;for(let n of r.materials||[])n.extensions&&n.extensions.KHR_materials_unlit&&(n.unlit=!0),e.removeObjectExtension(n,Ye);e.removeExtension(Ye)}function Al(t){let e=new _(t),{json:r}=e;if(e.materials)for(let n of r.materials||[])n.unlit&&(delete n.unlit,e.addObjectExtension(n,Ye,{}),e.addExtension(Ye))}var Qr={};P(Qr,{decode:()=>pl,encode:()=>hl,name:()=>ml});var We="KHR_techniques_webgl",ml=We;async function pl(t){let e=new _(t),{json:r}=e,n=e.getExtension(We);if(n){let o=ul(n,e);for(let s of r.materials||[]){let i=e.getObjectExtension(s,We);i&&(s.technique=Object.assign({},i,o[i.technique]),s.technique.values=dl(s.technique,e)),e.removeObjectExtension(s,We)}e.removeExtension(We)}}async function hl(t,e){}function ul(t,e){let{programs:r=[],shaders:n=[],techniques:o=[]}=t,s=new TextDecoder;return n.forEach(i=>{if(Number.isFinite(i.bufferView))i.code=s.decode(e.getTypedArrayForBufferView(i.bufferView));else throw new Error("KHR_techniques_webgl: no shader code")}),r.forEach(i=>{i.fragmentShader=n[i.fragmentShader],i.vertexShader=n[i.vertexShader]}),o.forEach(i=>{i.program=r[i.program]}),o}function dl(t,e){let r=Object.assign({},t.values);return Object.keys(t.uniforms||{}).forEach(n=>{t.uniforms[n].value&&!(n in r)&&(r[n]=t.uniforms[n].value)}),Object.keys(r).forEach(n=>{typeof r[n]=="object"&&r[n].index!==void 0&&(r[n].texture=e.getTexture(r[n].index))}),r}var Ks=[_r,Mr,Pr,wr,Nr,Vr,jr,kr,Qr,Xr,Tr];function Vs(t,e={},r){let n=Ks.filter(o=>js(o.name,e));for(let o of n)o.preprocess?.(t,e,r)}async function Xs(t,e={},r){let n=Ks.filter(o=>js(o.name,e));for(let o of n)await o.decode?.(t,e,r)}function js(t,e){let r=e?.gltf?.excludeExtensions||{};return!(t in r&&!r[t])}var zr="KHR_binary_glTF";function ks(t){let e=new _(t),{json:r}=e;for(let n of r.images||[]){let o=e.getObjectExtension(n,zr);o&&Object.assign(n,o),e.removeObjectExtension(n,zr)}r.buffers&&r.buffers[0]&&delete r.buffers[0].uri,e.removeExtension(zr)}var Qs={accessors:"accessor",animations:"animation",buffers:"buffer",bufferViews:"bufferView",images:"image",materials:"material",meshes:"mesh",nodes:"node",samplers:"sampler",scenes:"scene",skins:"skin",textures:"texture"},Bl={accessor:"accessors",animations:"animation",buffer:"buffers",bufferView:"bufferViews",image:"images",material:"materials",mesh:"meshes",node:"nodes",sampler:"samplers",scene:"scenes",skin:"skins",texture:"textures"},Yr=class{idToIndexMap={animations:{},accessors:{},buffers:{},bufferViews:{},images:{},materials:{},meshes:{},nodes:{},samplers:{},scenes:{},skins:{},textures:{}};json;normalize(e,r){this.json=e.json;let n=e.json;switch(n.asset&&n.asset.version){case"2.0":return;case void 0:case"1.0":break;default:console.warn(`glTF: Unknown version ${n.asset.version}`);return}if(!r.normalize)throw new Error("glTF v1 is not supported.");console.warn("Converting glTF v1 to glTF v2 format. This is experimental and may fail."),this._addAsset(n),this._convertTopLevelObjectsToArrays(n),ks(e),this._convertObjectIdsToArrayIndices(n),this._updateObjects(n),this._updateMaterial(n)}_addAsset(e){e.asset=e.asset||{},e.asset.version="2.0",e.asset.generator=e.asset.generator||"Normalized to glTF 2.0 by loaders.gl"}_convertTopLevelObjectsToArrays(e){for(let r in Qs)this._convertTopLevelObjectToArray(e,r)}_convertTopLevelObjectToArray(e,r){let n=e[r];if(!(!n||Array.isArray(n))){e[r]=[];for(let o in n){let s=n[o];s.id=s.id||o;let i=e[r].length;e[r].push(s),this.idToIndexMap[r][o]=i}}}_convertObjectIdsToArrayIndices(e){for(let r in Qs)this._convertIdsToIndices(e,r);"scene"in e&&(e.scene=this._convertIdToIndex(e.scene,"scene"));for(let r of e.textures)this._convertTextureIds(r);for(let r of e.meshes)this._convertMeshIds(r);for(let r of e.nodes)this._convertNodeIds(r);for(let r of e.scenes)this._convertSceneIds(r)}_convertTextureIds(e){e.source&&(e.source=this._convertIdToIndex(e.source,"image"))}_convertMeshIds(e){for(let r of e.primitives){let{attributes:n,indices:o,material:s}=r;for(let i in n)n[i]=this._convertIdToIndex(n[i],"accessor");o&&(r.indices=this._convertIdToIndex(o,"accessor")),s&&(r.material=this._convertIdToIndex(s,"material"))}}_convertNodeIds(e){e.children&&(e.children=e.children.map(r=>this._convertIdToIndex(r,"node"))),e.meshes&&(e.meshes=e.meshes.map(r=>this._convertIdToIndex(r,"mesh")))}_convertSceneIds(e){e.nodes&&(e.nodes=e.nodes.map(r=>this._convertIdToIndex(r,"node")))}_convertIdsToIndices(e,r){e[r]||(console.warn(`gltf v1: json doesn't contain attribute ${r}`),e[r]=[]);for(let n of e[r])for(let o in n){let s=n[o],i=this._convertIdToIndex(s,o);n[o]=i}}_convertIdToIndex(e,r){let n=Bl[r];if(n in this.idToIndexMap){let o=this.idToIndexMap[n][e];if(!Number.isFinite(o))throw new Error(`gltf v1: failed to resolve ${r} with id ${e}`);return o}return e}_updateObjects(e){for(let r of this.json.buffers)delete r.type}_updateMaterial(e){for(let r of e.materials){r.pbrMetallicRoughness={baseColorFactor:[1,1,1,1],metallicFactor:1,roughnessFactor:1};let n=r.values?.tex||r.values?.texture2d_0||r.values?.diffuseTex,o=e.textures.findIndex(s=>s.id===n);o!==-1&&(r.pbrMetallicRoughness.baseColorTexture={index:o})}}};function zs(t,e={}){return new Yr().normalize(t,e)}async function Ys(t,e,r=0,n,o){return Cl(t,e,r,n),zs(t,{normalize:n?.gltf?.normalize}),Vs(t,n,o),n?.gltf?.loadBuffers&&t.json.buffers&&await xl(t,n,o),n?.gltf?.loadImages&&await Ml(t,n,o),await Xs(t,n,o),t}function Cl(t,e,r,n){if(n.uri&&(t.baseUri=n.uri),e instanceof ArrayBuffer&&!Ss(e,r,n)&&(e=new TextDecoder().decode(e)),typeof e=="string")t.json=mr(e);else if(e instanceof ArrayBuffer){let i={};r=Fs(i,e,r,n.glb),R(i.type==="glTF",`Invalid GLB magic string ${i.type}`),t._glb=i,t.json=i.json}else R(!1,"GLTF: must be ArrayBuffer or string");let o=t.json.buffers||[];if(t.buffers=new Array(o.length).fill(null),t._glb&&t._glb.header.hasBinChunk){let{binChunks:i}=t._glb;t.buffers[0]={arrayBuffer:i[0].arrayBuffer,byteOffset:i[0].byteOffset,byteLength:i[0].byteLength}}let s=t.json.images||[];t.images=new Array(s.length).fill({})}async function xl(t,e,r){let n=t.json.buffers||[];for(let o=0;o<n.length;++o){let s=n[o];if(s.uri){let{fetch:i}=r;R(i);let a=Or(s.uri,e),f=await(await r?.fetch?.(a))?.arrayBuffer?.();t.buffers[o]={arrayBuffer:f,byteOffset:0,byteLength:f.byteLength},delete s.uri}else t.buffers[o]===null&&(t.buffers[o]={arrayBuffer:new ArrayBuffer(s.byteLength),byteOffset:0,byteLength:s.byteLength})}}async function Ml(t,e,r){let n=El(t),o=t.json.images||[],s=[];for(let i of n)s.push(bl(t,o[i],i,e,r));return await Promise.all(s)}function El(t){let e=new Set,r=t.json.textures||[];for(let n of r)n.source!==void 0&&e.add(n.source);return Array.from(e).sort()}async function bl(t,e,r,n,o){let s;if(e.uri&&!e.hasOwnProperty("bufferView")){let a=Or(e.uri,n),{fetch:c}=o;s=await(await c(a)).arrayBuffer(),e.bufferView={data:s}}if(Number.isFinite(e.bufferView)){let a=ms(t.json,t.buffers,e.bufferView);s=Ve(a.buffer,a.byteOffset,a.byteLength)}R(s,"glTF image has no data");let i=await Je(s,[Br,Fr],{...n,mimeType:e.mimeType,basis:n.basis||{format:Lt()}},o);i&&i[0]&&(i={compressed:!0,mipmaps:!1,width:i[0].width,height:i[0].height,data:i[0]}),t.images=t.images||[],t.images[r]=i}var qe={dataType:null,batchType:null,name:"glTF",id:"gltf",module:"gltf",version:Bs,extensions:["gltf","glb"],mimeTypes:["model/gltf+json","model/gltf-binary"],text:!0,binary:!0,tests:["glTF"],parse:_l,options:{gltf:{normalize:!0,loadBuffers:!0,loadImages:!0,decompressMeshes:!0},log:console}};async function _l(t,e={},r){e={...qe.options,...e},e.gltf={...qe.options.gltf,...e.gltf};let{byteOffset:n=0}=e;return await Ys({},t,n,e,r)}var Tl={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},yl={5120:1,5121:1,5122:2,5123:2,5125:4,5126:4},N={TEXTURE_MAG_FILTER:10240,TEXTURE_MIN_FILTER:10241,TEXTURE_WRAP_S:10242,TEXTURE_WRAP_T:10243,REPEAT:10497,LINEAR:9729,NEAREST_MIPMAP_LINEAR:9986},Rl={magFilter:N.TEXTURE_MAG_FILTER,minFilter:N.TEXTURE_MIN_FILTER,wrapS:N.TEXTURE_WRAP_S,wrapT:N.TEXTURE_WRAP_T},Il={[N.TEXTURE_MAG_FILTER]:N.LINEAR,[N.TEXTURE_MIN_FILTER]:N.NEAREST_MIPMAP_LINEAR,[N.TEXTURE_WRAP_S]:N.REPEAT,[N.TEXTURE_WRAP_T]:N.REPEAT};function Sl(){return{id:"default-sampler",parameters:Il}}function Fl(t){return yl[t]}function Ll(t){return Tl[t]}var Wr=class{baseUri="";jsonUnprocessed;json;buffers=[];images=[];postProcess(e,r={}){let{json:n,buffers:o=[],images:s=[]}=e,{baseUri:i=""}=e;return R(n),this.baseUri=i,this.buffers=o,this.images=s,this.jsonUnprocessed=n,this.json=this._resolveTree(e.json,r),this.json}_resolveTree(e,r={}){let n={...e};return this.json=n,e.bufferViews&&(n.bufferViews=e.bufferViews.map((o,s)=>this._resolveBufferView(o,s))),e.images&&(n.images=e.images.map((o,s)=>this._resolveImage(o,s))),e.samplers&&(n.samplers=e.samplers.map((o,s)=>this._resolveSampler(o,s))),e.textures&&(n.textures=e.textures.map((o,s)=>this._resolveTexture(o,s))),e.accessors&&(n.accessors=e.accessors.map((o,s)=>this._resolveAccessor(o,s))),e.materials&&(n.materials=e.materials.map((o,s)=>this._resolveMaterial(o,s))),e.meshes&&(n.meshes=e.meshes.map((o,s)=>this._resolveMesh(o,s))),e.nodes&&(n.nodes=e.nodes.map((o,s)=>this._resolveNode(o,s)),n.nodes=n.nodes.map((o,s)=>this._resolveNodeChildren(o))),e.skins&&(n.skins=e.skins.map((o,s)=>this._resolveSkin(o,s))),e.scenes&&(n.scenes=e.scenes.map((o,s)=>this._resolveScene(o,s))),typeof this.json.scene=="number"&&n.scenes&&(n.scene=n.scenes[this.json.scene]),n}getScene(e){return this._get(this.json.scenes,e)}getNode(e){return this._get(this.json.nodes,e)}getSkin(e){return this._get(this.json.skins,e)}getMesh(e){return this._get(this.json.meshes,e)}getMaterial(e){return this._get(this.json.materials,e)}getAccessor(e){return this._get(this.json.accessors,e)}getCamera(e){return this._get(this.json.cameras,e)}getTexture(e){return this._get(this.json.textures,e)}getSampler(e){return this._get(this.json.samplers,e)}getImage(e){return this._get(this.json.images,e)}getBufferView(e){return this._get(this.json.bufferViews,e)}getBuffer(e){return this._get(this.json.buffers,e)}_get(e,r){if(typeof r=="object")return r;let n=e&&e[r];return n||console.warn(`glTF file error: Could not find ${e}[${r}]`),n}_resolveScene(e,r){return{...e,id:e.id||`scene-${r}`,nodes:(e.nodes||[]).map(n=>this.getNode(n))}}_resolveNode(e,r){let n={...e,id:e?.id||`node-${r}`};return e.mesh!==void 0&&(n.mesh=this.getMesh(e.mesh)),e.camera!==void 0&&(n.camera=this.getCamera(e.camera)),e.skin!==void 0&&(n.skin=this.getSkin(e.skin)),e.meshes!==void 0&&e.meshes.length&&(n.mesh=e.meshes.reduce((o,s)=>{let i=this.getMesh(s);return o.id=i.id,o.primitives=o.primitives.concat(i.primitives),o},{primitives:[]})),n}_resolveNodeChildren(e){return e.children&&(e.children=e.children.map(r=>this.getNode(r))),e}_resolveSkin(e,r){let n=typeof e.inverseBindMatrices=="number"?this.getAccessor(e.inverseBindMatrices):void 0;return{...e,id:e.id||`skin-${r}`,inverseBindMatrices:n}}_resolveMesh(e,r){let n={...e,id:e.id||`mesh-${r}`,primitives:[]};return e.primitives&&(n.primitives=e.primitives.map(o=>{let s={...o,attributes:{},indices:void 0,material:void 0},i=o.attributes;for(let a in i)s.attributes[a]=this.getAccessor(i[a]);return o.indices!==void 0&&(s.indices=this.getAccessor(o.indices)),o.material!==void 0&&(s.material=this.getMaterial(o.material)),s})),n}_resolveMaterial(e,r){let n={...e,id:e.id||`material-${r}`};if(n.normalTexture&&(n.normalTexture={...n.normalTexture},n.normalTexture.texture=this.getTexture(n.normalTexture.index)),n.occlusionTexture&&(n.occlusionTexture={...n.occlusionTexture},n.occlusionTexture.texture=this.getTexture(n.occlusionTexture.index)),n.emissiveTexture&&(n.emissiveTexture={...n.emissiveTexture},n.emissiveTexture.texture=this.getTexture(n.emissiveTexture.index)),n.emissiveFactor||(n.emissiveFactor=n.emissiveTexture?[1,1,1]:[0,0,0]),n.pbrMetallicRoughness){n.pbrMetallicRoughness={...n.pbrMetallicRoughness};let o=n.pbrMetallicRoughness;o.baseColorTexture&&(o.baseColorTexture={...o.baseColorTexture},o.baseColorTexture.texture=this.getTexture(o.baseColorTexture.index)),o.metallicRoughnessTexture&&(o.metallicRoughnessTexture={...o.metallicRoughnessTexture},o.metallicRoughnessTexture.texture=this.getTexture(o.metallicRoughnessTexture.index))}return n}_resolveAccessor(e,r){let n=Fl(e.componentType),o=Ll(e.type),s=n*o,i={...e,id:e.id||`accessor-${r}`,bytesPerComponent:n,components:o,bytesPerElement:s,value:void 0,bufferView:void 0,sparse:void 0};if(e.bufferView!==void 0&&(i.bufferView=this.getBufferView(e.bufferView)),i.bufferView){let a=i.bufferView.buffer,{ArrayType:c,byteLength:f}=be(i,i.bufferView),l=(i.bufferView.byteOffset||0)+(i.byteOffset||0)+a.byteOffset,A=a.arrayBuffer.slice(l,l+f);i.bufferView.byteStride&&(A=this._getValueFromInterleavedBuffer(a,l,i.bufferView.byteStride,i.bytesPerElement,i.count)),i.value=new c(A)}return i}_getValueFromInterleavedBuffer(e,r,n,o,s){let i=new Uint8Array(s*o);for(let a=0;a<s;a++){let c=r+a*n;i.set(new Uint8Array(e.arrayBuffer.slice(c,c+o)),a*o)}return i.buffer}_resolveTexture(e,r){return{...e,id:e.id||`texture-${r}`,sampler:typeof e.sampler=="number"?this.getSampler(e.sampler):Sl(),source:typeof e.source=="number"?this.getImage(e.source):void 0}}_resolveSampler(e,r){let n={id:e.id||`sampler-${r}`,...e,parameters:{}};for(let o in n){let s=this._enumSamplerParameter(o);s!==void 0&&(n.parameters[s]=n[o])}return n}_enumSamplerParameter(e){return Rl[e]}_resolveImage(e,r){let n={...e,id:e.id||`image-${r}`,image:null,bufferView:e.bufferView!==void 0?this.getBufferView(e.bufferView):void 0},o=this.images[r];return o&&(n.image=o),n}_resolveBufferView(e,r){let n=e.buffer,o=this.buffers[n].arrayBuffer,s=this.buffers[n].byteOffset||0;return e.byteOffset&&(s+=e.byteOffset),{id:`bufferView-${r}`,...e,buffer:this.buffers[n],data:new Uint8Array(o,s,e.byteLength)}}_resolveCamera(e,r){let n={...e,id:e.id||`camera-${r}`};return n.perspective,n.orthographic,n}};function qr(t,e){return new Wr().postProcess(t,e)}async function Ws(t){let e=[];return t.scenes.forEach(r=>{r.traverse(n=>{})}),await vl(()=>e.some(r=>!r.loaded))}async function vl(t){for(;t();)await new Promise(e=>requestAnimationFrame(e))}var qs=`uniform scenegraphUniforms {
  float sizeScale;
  float sizeMinPixels;
  float sizeMaxPixels;
  mat4 sceneModelMatrix;
  bool composeModelMatrix;
} scenegraph;
`,Zs={name:"scenegraph",vs:qs,fs:qs,uniformTypes:{sizeScale:"f32",sizeMinPixels:"f32",sizeMaxPixels:"f32",sceneModelMatrix:"mat4x4<f32>",composeModelMatrix:"f32"}};var $s=`#version 300 es
#define SHADER_NAME scenegraph-layer-vertex-shader
in vec3 instancePositions;
in vec3 instancePositions64Low;
in vec4 instanceColors;
in vec3 instancePickingColors;
in vec3 instanceModelMatrixCol0;
in vec3 instanceModelMatrixCol1;
in vec3 instanceModelMatrixCol2;
in vec3 instanceTranslation;
in vec3 positions;
#ifdef HAS_UV
in vec2 texCoords;
#endif
#ifdef LIGHTING_PBR
#ifdef HAS_NORMALS
in vec3 normals;
#endif
#endif
out vec4 vColor;
#ifndef LIGHTING_PBR
#ifdef HAS_UV
out vec2 vTEXCOORD_0;
#endif
#endif
void main(void) {
#if defined(HAS_UV) && !defined(LIGHTING_PBR)
vTEXCOORD_0 = texCoords;
geometry.uv = texCoords;
#endif
geometry.worldPosition = instancePositions;
geometry.pickingColor = instancePickingColors;
mat3 instanceModelMatrix = mat3(instanceModelMatrixCol0, instanceModelMatrixCol1, instanceModelMatrixCol2);
vec3 normal = vec3(0.0, 0.0, 1.0);
#ifdef LIGHTING_PBR
#ifdef HAS_NORMALS
normal = instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(normals, 0.0)).xyz;
#endif
#endif
float originalSize = project_size_to_pixel(scenegraph.sizeScale);
float clampedSize = clamp(originalSize, scenegraph.sizeMinPixels, scenegraph.sizeMaxPixels);
vec3 pos = (instanceModelMatrix * (scenegraph.sceneModelMatrix * vec4(positions, 1.0)).xyz) * scenegraph.sizeScale * (clampedSize / originalSize) + instanceTranslation;
if(scenegraph.composeModelMatrix) {
DECKGL_FILTER_SIZE(pos, geometry);
geometry.normal = project_normal(normal);
geometry.worldPosition += pos;
gl_Position = project_position_to_clipspace(pos + instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
}
else {
pos = project_size(pos);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, pos, geometry.position);
geometry.normal = project_normal(normal);
}
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
#ifdef LIGHTING_PBR
pbr_vPosition = geometry.position.xyz;
#ifdef HAS_NORMALS
pbr_vNormal = geometry.normal;
#endif
#ifdef HAS_UV
pbr_vUV = texCoords;
#else
pbr_vUV = vec2(0., 0.);
#endif
geometry.uv = pbr_vUV;
#endif
vColor = instanceColors;
DECKGL_FILTER_COLOR(vColor, geometry);
}
`;var ei=`#version 300 es
#define SHADER_NAME scenegraph-layer-fragment-shader
in vec4 vColor;
out vec4 fragColor;
#ifndef LIGHTING_PBR
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
in vec2 vTEXCOORD_0;
uniform sampler2D pbr_baseColorSampler;
#endif
#endif
void main(void) {
#ifdef LIGHTING_PBR
fragColor = vColor * pbr_filterColor(vec4(0));
geometry.uv = pbr_vUV;
#else
#if defined(HAS_UV) && defined(HAS_BASECOLORMAP)
fragColor = vColor * texture(pbr_baseColorSampler, vTEXCOORD_0);
geometry.uv = vTEXCOORD_0;
#else
fragColor = vColor;
#endif
#endif
fragColor.a *= layer.opacity;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`;var ti=[255,255,255,255],Gl={scenegraph:{type:"object",value:null,async:!0},getScene:t=>t&&t.scenes?typeof t.scene=="object"?t.scene:t.scenes[t.scene||0]:t,getAnimator:t=>t&&t.animator,_animations:null,sizeScale:{type:"number",value:1,min:0},sizeMinPixels:{type:"number",min:0,value:0},sizeMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},getPosition:{type:"accessor",value:t=>t.position},getColor:{type:"accessor",value:ti},_lighting:"flat",_imageBasedLightingEnvironment:void 0,getOrientation:{type:"accessor",value:[0,0,0]},getScale:{type:"accessor",value:[1,1,1]},getTranslation:{type:"accessor",value:[0,0,0]},getTransformMatrix:{type:"accessor",value:[]},loaders:[qe]},Ze=class extends Q.Layer{getShaders(){let e={},r;this.props._lighting==="pbr"?(r=we,e.LIGHTING_PBR=1):r={name:"pbrMaterial"};let n=[Q.project32,Q.picking,Zs,r];return super.getShaders({defines:e,vs:$s,fs:ei,modules:n})}initializeState(){this.getAttributeManager().addInstanced({instancePositions:{size:3,type:"float64",fp64:this.use64bitPositions(),accessor:"getPosition",transition:!0},instanceColors:{type:"unorm8",size:this.props.colorFormat.length,accessor:"getColor",defaultValue:ti,transition:!0},instanceModelMatrix:ht})}updateState(e){super.updateState(e);let{props:r,oldProps:n}=e;r.scenegraph!==n.scenegraph?this._updateScenegraph():r._animations!==n._animations&&this._applyAnimationsProp(this.state.animator,r._animations)}finalizeState(e){super.finalizeState(e),this.state.scenegraph?.destroy()}get isLoaded(){return Boolean(this.state?.scenegraph&&super.isLoaded)}_updateScenegraph(){let e=this.props,{device:r}=this.context,n=null;if(e.scenegraph instanceof me.ScenegraphNode)n={scenes:[e.scenegraph]};else if(e.scenegraph&&typeof e.scenegraph=="object"){let a=e.scenegraph,c=a.json?qr(a):a,f=cr(r,c,this._getModelOptions());n={gltf:c,...f},Ws(f).then(()=>{this.setNeedsRedraw()}).catch(l=>{this.raiseError(l,"loading glTF")})}let o={layer:this,device:this.context.device},s=e.getScene(n,o),i=e.getAnimator(n,o);if(s instanceof me.GroupNode){this.state.scenegraph?.destroy(),this._applyAnimationsProp(i,e._animations);let a=[];s.traverse(c=>{c instanceof me.ModelNode&&a.push(c.model)}),this.setState({scenegraph:s,animator:i,models:a}),this.getAttributeManager().invalidateAll()}else s!==null&&Q.log.warn("invalid scenegraph:",s)()}_applyAnimationsProp(e,r){if(!e||!r)return;let n=e.getAnimations();Object.keys(r).sort().forEach(o=>{let s=r[o];if(o==="*")n.forEach(i=>{Object.assign(i,s)});else if(Number.isFinite(Number(o))){let i=Number(o);i>=0&&i<n.length?Object.assign(n[i],s):Q.log.warn(`animation ${o} not found`)()}else{let i=n.find(({animation:a})=>a.name===o);i?Object.assign(i,s):Q.log.warn(`animation ${o} not found`)()}})}_getModelOptions(){let{_imageBasedLightingEnvironment:e}=this.props,r;return e&&(typeof e=="function"?r=e({gl:this.context.gl,layer:this}):r=e),{imageBasedLightingEnvironment:r,modelOptions:{id:this.props.id,isInstanced:!0,bufferLayout:this.getAttributeManager().getBufferLayouts(),...this.getShaders()},useTangents:!1}}draw({context:e}){if(!this.state.scenegraph)return;this.props._animations&&this.state.animator&&(this.state.animator.animate(e.timeline.getTime()),this.setNeedsRedraw());let{viewport:r,renderPass:n}=this.context,{sizeScale:o,sizeMinPixels:s,sizeMaxPixels:i,coordinateSystem:a}=this.props,c={camera:r.cameraPosition},f=this.getNumInstances();this.state.scenegraph.traverse((l,{worldMatrix:A})=>{if(l instanceof me.ModelNode){let{model:m}=l;m.setInstanceCount(f);let p={sizeScale:o,sizeMinPixels:s,sizeMaxPixels:i,composeModelMatrix:ut(r,a),sceneModelMatrix:A};m.shaderInputs.setProps({pbrProjection:c,scenegraph:p}),m.draw(n)}})}};Ze.defaultProps=Gl;Ze.layerName="ScenegraphLayer";var ri=Ze;return ci($e);})();
      return __exports__;
      });
